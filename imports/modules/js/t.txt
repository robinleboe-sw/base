1,3c1,21
< //
< // the below code is a copy of the standard polyfill adapter.js
< //
---
> /*
>  *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
>  *
>  *  Use of this source code is governed by a BSD-style license
>  *  that can be found in the LICENSE file in the root of the source
>  *  tree.
>  */
> 
> /* More information about these options at jshint.com/docs/options */
> /* jshint browser: true, camelcase: true, curly: true, devel: true,
>    eqeqeq: true, forin: false, globalstrict: true, node: true,
>    quotmark: single, undef: true, unused: strict */
>    
> /* global mozRTCIceCandidate, mozRTCPeerConnection, Promise,
> mozRTCSessionDescription, webkitRTCPeerConnection, MediaStreamTrack,
> MediaStream, RTCIceGatherer, RTCIceTransport, RTCDtlsTransport,
> RTCRtpSender, RTCRtpReceiver, RTCSessionDescription*/
> /* exported trace */
> 
> 'use strict';
> 
9,10c27,36
< if (navigator.mozGetUserMedia) {
< // console.log("This appears to be Firefox");
---
> var webrtcMinimumVersion = null;
> var webrtcUtils = {
>   log: function() {
>     console.log.apply(console, arguments);
>   },
>   extractVersion: function(uastring, expr, pos) {
>     var match = uastring.match(expr);
>     return match && match.length >= pos && parseInt(match[pos], 10);
>   }
> };
12c38,49
<     webrtcDetectedBrowser = "firefox";
---
> function trace(text) {
>   // This function is used for logging.
>   if (text[text.length - 1] === '\n') {
>     text = text.substring(0, text.length - 1);
>   }
>   if (window.performance) {
>     var now = (window.performance.now() / 1000).toFixed(3);
>     webrtcUtils.log(now + ': ' + text);
>   } else {
>     webrtcUtils.log(text);
>   }
> }
14,20c51,151
<     //
<     // better version detection for gecko based browsers provided by
<     // KÃ©vin Poulet.
<     //
<     var matches = navigator.userAgent.match(/\srv:([0-9]+)\./);
<     if (matches !== null && matches.length > 1) {
<         webrtcDetectedVersion = parseInt(matches[1]);
---
> if (typeof window === 'object') {
>   if (window.HTMLMediaElement &&
>     !('srcObject' in window.HTMLMediaElement.prototype)) {
>     // Shim the srcObject property, once, when HTMLMediaElement is found.
>     Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
>       get: function() {
>         // If prefixed srcObject property exists, return it.
>         // Otherwise use the shimmed property, _srcObject
>         return 'mozSrcObject' in this ? this.mozSrcObject : this._srcObject;
>       },
>       set: function(stream) {
>         if ('mozSrcObject' in this) {
>           this.mozSrcObject = stream;
>         } else {
>           // Use _srcObject as a private property for this shim
>           this._srcObject = stream;
>           // TODO: revokeObjectUrl(this.src) when !stream to release resources?
>           this.src = URL.createObjectURL(stream);
>         }
>       }
>     });
>   }
>   // Proxy existing globals
>   getUserMedia = window.navigator && window.navigator.getUserMedia;
> }
> 
> // Returns the result of getUserMedia as a Promise.
> function requestUserMedia(constraints) {
>   return new Promise(function(resolve, reject) {
>     getUserMedia(constraints, resolve, reject);
>   });
> }
> 
> 
> // Attach a media stream to an element.
> attachMediaStream = function(element, stream) {
>   element.srcObject = stream;
> };
> 
> reattachMediaStream = function(to, from) {
>   to.srcObject = from.srcObject;
> };
> 
> if (typeof window === 'undefined' || !window.navigator) {
>   webrtcUtils.log('This does not appear to be a browser');
>   webrtcDetectedBrowser = 'not a browser';
> } else if (navigator.mozGetUserMedia) {
>   webrtcUtils.log('This appears to be Firefox');
> 
>   webrtcDetectedBrowser = 'firefox';
> 
>   // the detected firefox version.
>   webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
>       /Firefox\/([0-9]+)\./, 1);
> 
>   // the minimum firefox version still supported by adapter.
>   webrtcMinimumVersion = 31;
> 
>   // Shim for RTCPeerConnection on older versions.
>   if (!window.RTCPeerConnection) {
>     window.RTCPeerConnection = function(pcConfig, pcConstraints) {
>       if (webrtcDetectedVersion < 38) {
>         // .urls is not supported in FF < 38.
>         // create RTCIceServers with a single url.
>         if (pcConfig && pcConfig.iceServers) {
>           var newIceServers = [];
>           for (var i = 0; i < pcConfig.iceServers.length; i++) {
>             var server = pcConfig.iceServers[i];
>             if (server.hasOwnProperty('urls')) {
>               for (var j = 0; j < server.urls.length; j++) {
>                 var newServer = {
>                   url: server.urls[j]
>                 };
>                 if (server.urls[j].indexOf('turn') === 0) {
>                   newServer.username = server.username;
>                   newServer.credential = server.credential;
>                 }
>                 newIceServers.push(newServer);
>               }
>             } else {
>               newIceServers.push(pcConfig.iceServers[i]);
>             }
>           }
>           pcConfig.iceServers = newIceServers;
>         }
>       }
>       return new mozRTCPeerConnection(pcConfig, pcConstraints); // jscs:ignore requireCapitalizedConstructors
>     };
> 
>     // wrap static methods. Currently just generateCertificate.
>     if (mozRTCPeerConnection.generateCertificate) {
>       Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
>         get: function() {
>           if (arguments.length) {
>             return mozRTCPeerConnection.generateCertificate.apply(null,
>                 arguments);
>           } else {
>             return mozRTCPeerConnection.generateCertificate;
>           }
>         }
>       });
23,25d153
<     // The RTCPeerConnection object.
<     window.RTCPeerConnection = mozRTCPeerConnection;
<     // The RTCSessionDescription object.
27d154
<     // The RTCIceCandidate object.
29,69c156,301
<     // Get UserMedia (only difference is the prefix).
<     // Code from Adam Barth.
<     window.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
<     // Creates iceServer from the url for FF.
<     window.createIceServer = function(url, username, password) {
<         var iceServer = null;
<         var url_parts = url.split(':');
<         var turn_url_parts;
<         if (url_parts[0].indexOf('stun') === 0) {
<             // Create iceServer with stun url.
<             iceServer = {'url': url};
<         } else if (url_parts[0].indexOf('turn') === 0 &&
<                 (url.indexOf('transport=udp') !== -1 ||
<                         url.indexOf('?transport') === -1)) {
<             // Create iceServer with turn url.
<             // Ignore the transport parameter from TURN url.
<             turn_url_parts = url.split("?");
<             iceServer = {'url': turn_url_parts[0],
<                 'credential': password,
<                 'username': username};
<         }
<         return iceServer;
<     };
<     // Attach a media stream to an element.
<     attachMediaStream = function(element, stream) {
< //        console.log("Attaching media stream");
<         element.mozSrcObject = stream;
<         element.play();
<     };
<     reattachMediaStream = function(to, from) {
< //        console.log("Reattaching media stream");
<         to.mozSrcObject = from.mozSrcObject;
<         to.play();
<     };
<     if (webrtcDetectedVersion < 23) {
< // Fake get{Video,Audio}Tracks
<         MediaStream.prototype.getVideoTracks = function() {
<             return [];
<         };
<         MediaStream.prototype.getAudioTracks = function() {
<             return [];
---
>   }
> 
>   // getUserMedia constraints shim.
>   getUserMedia = function(constraints, onSuccess, onError) {
>     var constraintsToFF37 = function(c) {
>       if (typeof c !== 'object' || c.require) {
>         return c;
>       }
>       var require = [];
>       Object.keys(c).forEach(function(key) {
>         if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
>           return;
>         }
>         var r = c[key] = (typeof c[key] === 'object') ?
>             c[key] : {ideal: c[key]};
>         if (r.min !== undefined ||
>             r.max !== undefined || r.exact !== undefined) {
>           require.push(key);
>         }
>         if (r.exact !== undefined) {
>           if (typeof r.exact === 'number') {
>             r.min = r.max = r.exact;
>           } else {
>             c[key] = r.exact;
>           }
>           delete r.exact;
>         }
>         if (r.ideal !== undefined) {
>           c.advanced = c.advanced || [];
>           var oc = {};
>           if (typeof r.ideal === 'number') {
>             oc[key] = {min: r.ideal, max: r.ideal};
>           } else {
>             oc[key] = r.ideal;
>           }
>           c.advanced.push(oc);
>           delete r.ideal;
>           if (!Object.keys(r).length) {
>             delete c[key];
>           }
>         }
>       });
>       if (require.length) {
>         c.require = require;
>       }
>       return c;
>     };
>     if (webrtcDetectedVersion < 38) {
>       webrtcUtils.log('spec: ' + JSON.stringify(constraints));
>       if (constraints.audio) {
>         constraints.audio = constraintsToFF37(constraints.audio);
>       }
>       if (constraints.video) {
>         constraints.video = constraintsToFF37(constraints.video);
>       }
>       webrtcUtils.log('ff37: ' + JSON.stringify(constraints));
>     }
>     return navigator.mozGetUserMedia(constraints, onSuccess, onError);
>   };
> 
>   navigator.getUserMedia = getUserMedia;
> 
>   // Shim for mediaDevices on older versions.
>   if (!navigator.mediaDevices) {
>     navigator.mediaDevices = {getUserMedia: requestUserMedia,
>       addEventListener: function() { },
>       removeEventListener: function() { }
>     };
>   }
>   navigator.mediaDevices.enumerateDevices =
>       navigator.mediaDevices.enumerateDevices || function() {
>     return new Promise(function(resolve) {
>       var infos = [
>         {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
>         {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
>       ];
>       resolve(infos);
>     });
>   };
> 
>   if (webrtcDetectedVersion < 41) {
>     // Work around http://bugzil.la/1169665
>     var orgEnumerateDevices =
>         navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
>     navigator.mediaDevices.enumerateDevices = function() {
>       return orgEnumerateDevices().then(undefined, function(e) {
>         if (e.name === 'NotFoundError') {
>           return [];
>         }
>         throw e;
>       });
>     };
>   }
> } else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection && !window.RTCPeerConnection) {
>   webrtcUtils.log('This appears to be Chrome');
> 
>   webrtcDetectedBrowser = 'chrome';
> 
>   // the detected chrome version.
>   webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
>       /Chrom(e|ium)\/([0-9]+)\./, 2);
> 
>   // the minimum chrome version still supported by adapter.
>   webrtcMinimumVersion = 38;
> 
>   // The RTCPeerConnection object.
>   window.RTCPeerConnection = function(pcConfig, pcConstraints) {
>     // Translate iceTransportPolicy to iceTransports,
>     // see https://code.google.com/p/webrtc/issues/detail?id=4869
>     if (pcConfig && pcConfig.iceTransportPolicy) {
>       pcConfig.iceTransports = pcConfig.iceTransportPolicy;
>     }
> 
>     var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints); // jscs:ignore requireCapitalizedConstructors
>     var origGetStats = pc.getStats.bind(pc);
>     pc.getStats = function(selector, successCallback, errorCallback) { // jshint ignore: line
>       var self = this;
>       var args = arguments;
> 
>       // If selector is a function then we are in the old style stats so just
>       // pass back the original getStats format to avoid breaking old users.
>       if (arguments.length > 0 && typeof selector === 'function') {
>         return origGetStats(selector, successCallback);
>       }
> 
>       var fixChromeStats = function(response) {
>         var standardReport = {};
>         var reports = response.result();
>         reports.forEach(function(report) {
>           var standardStats = {
>             id: report.id,
>             timestamp: report.timestamp,
>             type: report.type
>           };
>           report.names().forEach(function(name) {
>             standardStats[name] = report.stat(name);
>           });
>           standardReport[standardStats.id] = standardStats;
>         });
> 
>         return standardReport;
>       };
> 
>       if (arguments.length >= 2) {
>         var successCallbackWrapper = function(response) {
>           args[1](fixChromeStats(response));
71,73d302
<     }
< } else if (navigator.webkitGetUserMedia) {
< //    console.log("This appears to be Chrome");
75,113c304,313
<     webrtcDetectedBrowser = "chrome";
<     webrtcDetectedVersion =
<             parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]);
<     // Creates iceServer from the url for Chrome.
<     window.createIceServer = function(url, username, password) {
<         var iceServer = null;
<         var url_turn_parts;
<         var url_parts = url.split(':');
<         if (url_parts[0].indexOf('stun') === 0) {
< // Create iceServer with stun url.
<             iceServer = {'url': url};
<         } else if (url_parts[0].indexOf('turn') === 0) {
<             if (webrtcDetectedVersion < 28) {
< // For pre-M28 chrome versions use old TURN format.
<                 url_turn_parts = url.split("turn:");
<                 iceServer = {'url': 'turn:' + username + '@' + url_turn_parts[1],
<                     'credential': password};
<             } else {
< // For Chrome M28 & above use new TURN format.
<                 iceServer = {'url': url,
<                     'credential': password,
<                     'username': username};
<             }
<         }
<         return iceServer;
<     };
<     // The RTCPeerConnection object.
<     window.RTCPeerConnection = webkitRTCPeerConnection;
<     // Get UserMedia (only difference is the prefix).
<     // Code from Adam Barth.
<     window.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
<     // Attach a media stream to an element.
<     attachMediaStream = function(element, stream) {
<         if (typeof element.srcObject !== 'undefined') {
<             element.srcObject = stream;
<         } else if (typeof element.mozSrcObject !== 'undefined') {
<             element.mozSrcObject = stream;
<         } else if (typeof element.src !== 'undefined') {
<             element.src = URL.createObjectURL(stream);
---
>         return origGetStats.apply(this, [successCallbackWrapper, arguments[0]]);
>       }
> 
>       // promise-support
>       return new Promise(function(resolve, reject) {
>         if (args.length === 1 && selector === null) {
>           origGetStats.apply(self, [
>               function(response) {
>                 resolve.apply(null, [fixChromeStats(response)]);
>               }, reject]);
115c315
<             console.log('Error attaching stream to element.');
---
>           origGetStats.apply(self, [resolve, reject]);
116a317
>       });
118,119c319,706
<     reattachMediaStream = function(to, from) {
<         to.src = from.src;
---
> 
>     return pc;
>   };
> 
>   // wrap static methods. Currently just generateCertificate.
>   if (webkitRTCPeerConnection.generateCertificate) {
>     Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
>       get: function() {
>         if (arguments.length) {
>           return webkitRTCPeerConnection.generateCertificate.apply(null,
>               arguments);
>         } else {
>           return webkitRTCPeerConnection.generateCertificate;
>         }
>       }
>     });
>   }
> 
>   // add promise support
>   ['createOffer', 'createAnswer'].forEach(function(method) {
>     var nativeMethod = webkitRTCPeerConnection.prototype[method];
>     webkitRTCPeerConnection.prototype[method] = function() {
>       var self = this;
>       if (arguments.length < 1 || (arguments.length === 1 &&
>           typeof(arguments[0]) === 'object')) {
>         var opts = arguments.length === 1 ? arguments[0] : undefined;
>         return new Promise(function(resolve, reject) {
>           nativeMethod.apply(self, [resolve, reject, opts]);
>         });
>       } else {
>         return nativeMethod.apply(this, arguments);
>       }
>     };
>   });
> 
>   ['setLocalDescription', 'setRemoteDescription',
>       'addIceCandidate'].forEach(function(method) {
>     var nativeMethod = webkitRTCPeerConnection.prototype[method];
>     webkitRTCPeerConnection.prototype[method] = function() {
>       var args = arguments;
>       var self = this;
>       return new Promise(function(resolve, reject) {
>         nativeMethod.apply(self, [args[0],
>             function() {
>               resolve();
>               if (args.length >= 2) {
>                 args[1].apply(null, []);
>               }
>             },
>             function(err) {
>               reject(err);
>               if (args.length >= 3) {
>                 args[2].apply(null, [err]);
>               }
>             }]
>           );
>       });
>     };
>   });
> 
>   // getUserMedia constraints shim.
>   var constraintsToChrome = function(c) {
>     if (typeof c !== 'object' || c.mandatory || c.optional) {
>       return c;
>     }
>     var cc = {};
>     Object.keys(c).forEach(function(key) {
>       if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
>         return;
>       }
>       var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
>       if (r.exact !== undefined && typeof r.exact === 'number') {
>         r.min = r.max = r.exact;
>       }
>       var oldname = function(prefix, name) {
>         if (prefix) {
>           return prefix + name.charAt(0).toUpperCase() + name.slice(1);
>         }
>         return (name === 'deviceId') ? 'sourceId' : name;
>       };
>       if (r.ideal !== undefined) {
>         cc.optional = cc.optional || [];
>         var oc = {};
>         if (typeof r.ideal === 'number') {
>           oc[oldname('min', key)] = r.ideal;
>           cc.optional.push(oc);
>           oc = {};
>           oc[oldname('max', key)] = r.ideal;
>           cc.optional.push(oc);
>         } else {
>           oc[oldname('', key)] = r.ideal;
>           cc.optional.push(oc);
>         }
>       }
>       if (r.exact !== undefined && typeof r.exact !== 'number') {
>         cc.mandatory = cc.mandatory || {};
>         cc.mandatory[oldname('', key)] = r.exact;
>       } else {
>         ['min', 'max'].forEach(function(mix) {
>           if (r[mix] !== undefined) {
>             cc.mandatory = cc.mandatory || {};
>             cc.mandatory[oldname(mix, key)] = r[mix];
>           }
>         });
>       }
>     });
>     if (c.advanced) {
>       cc.optional = (cc.optional || []).concat(c.advanced);
>     }
>     return cc;
>   };
> 
>   getUserMedia = function(constraints, onSuccess, onError) {
>     if (constraints.audio) {
>       constraints.audio = constraintsToChrome(constraints.audio);
>     }
>     if (constraints.video) {
>       constraints.video = constraintsToChrome(constraints.video);
>     }
>     webrtcUtils.log('chrome: ' + JSON.stringify(constraints));
>     return navigator.webkitGetUserMedia(constraints, onSuccess, onError);
>   };
>   navigator.getUserMedia = getUserMedia;
> 
>   if (!navigator.mediaDevices) {
>     navigator.mediaDevices = {getUserMedia: requestUserMedia,
>                               enumerateDevices: function() {
>       return new Promise(function(resolve) {
>         var kinds = {audio: 'audioinput', video: 'videoinput'};
>         return MediaStreamTrack.getSources(function(devices) {
>           resolve(devices.map(function(device) {
>             return {label: device.label,
>                     kind: kinds[device.kind],
>                     deviceId: device.id,
>                     groupId: ''};
>           }));
>         });
>       });
>     }};
>   }
> 
>   // A shim for getUserMedia method on the mediaDevices object.
>   // TODO(KaptenJansson) remove once implemented in Chrome stable.
>   if (!navigator.mediaDevices.getUserMedia) {
>     navigator.mediaDevices.getUserMedia = function(constraints) {
>       return requestUserMedia(constraints);
>     };
>   } else {
>     // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
>     // function which returns a Promise, it does not accept spec-style
>     // constraints.
>     var origGetUserMedia = navigator.mediaDevices.getUserMedia.
>         bind(navigator.mediaDevices);
>     navigator.mediaDevices.getUserMedia = function(c) {
>       webrtcUtils.log('spec:   ' + JSON.stringify(c)); // whitespace for alignment
>       c.audio = constraintsToChrome(c.audio);
>       c.video = constraintsToChrome(c.video);
>       webrtcUtils.log('chrome: ' + JSON.stringify(c));
>       return origGetUserMedia(c);
>     };
>   }
> 
>   // Dummy devicechange event methods.
>   // TODO(KaptenJansson) remove once implemented in Chrome stable.
>   if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
>     navigator.mediaDevices.addEventListener = function() {
>       webrtcUtils.log('Dummy mediaDevices.addEventListener called.');
>     };
>   }
>   if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
>     navigator.mediaDevices.removeEventListener = function() {
>       webrtcUtils.log('Dummy mediaDevices.removeEventListener called.');
>     };
>   }
> 
>   // Attach a media stream to an element.
>   attachMediaStream = function(element, stream) {
>     if (webrtcDetectedVersion >= 43) {
>       element.srcObject = stream;
>     } else if (typeof element.src !== 'undefined') {
>       element.src = URL.createObjectURL(stream);
>     } else {
>       webrtcUtils.log('Error attaching stream to element.');
>     }
>   };
>   reattachMediaStream = function(to, from) {
>     if (webrtcDetectedVersion >= 43) {
>       to.srcObject = from.srcObject;
>     } else {
>       to.src = from.src;
>     }
>   };
> 
> } else if (navigator.mediaDevices && navigator.userAgent.match(
>     /Edge\/(\d+).(\d+)$/)) {
>   webrtcUtils.log('This appears to be Edge');
>   webrtcDetectedBrowser = 'edge';
> 
>   webrtcDetectedVersion = webrtcUtils.extractVersion(navigator.userAgent,
>       /Edge\/(\d+).(\d+)$/, 2);
> 
>   // The minimum version still supported by adapter.
>   // This is the build number for Edge.
>   webrtcMinimumVersion = 10547;
> 
>   if (window.RTCIceGatherer) {
>     // Generate an alphanumeric identifier for cname or mids.
>     // TODO: use UUIDs instead? https://gist.github.com/jed/982883
>     var generateIdentifier = function() {
>       return Math.random().toString(36).substr(2, 10);
>     };
> 
>     // The RTCP CNAME used by all peerconnections from the same JS.
>     var localCName = generateIdentifier();
> 
>     // SDP helpers - to be moved into separate module.
>     var SDPUtils = {};
> 
>     // Splits SDP into lines, dealing with both CRLF and LF.
>     SDPUtils.splitLines = function(blob) {
>       return blob.trim().split('\n').map(function(line) {
>         return line.trim();
>       });
>     };
> 
>     // Splits SDP into sessionpart and mediasections. Ensures CRLF.
>     SDPUtils.splitSections = function(blob) {
>       var parts = blob.split('\r\nm=');
>       return parts.map(function(part, index) {
>         return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
>       });
>     };
> 
>     // Returns lines that start with a certain prefix.
>     SDPUtils.matchPrefix = function(blob, prefix) {
>       return SDPUtils.splitLines(blob).filter(function(line) {
>         return line.indexOf(prefix) === 0;
>       });
>     };
> 
>     // Parses an ICE candidate line. Sample input:
>     // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8 rport 55996"
>     SDPUtils.parseCandidate = function(line) {
>       var parts;
>       // Parse both variants.
>       if (line.indexOf('a=candidate:') === 0) {
>         parts = line.substring(12).split(' ');
>       } else {
>         parts = line.substring(10).split(' ');
>       }
> 
>       var candidate = {
>         foundation: parts[0],
>         component: parts[1],
>         protocol: parts[2].toLowerCase(),
>         priority: parseInt(parts[3], 10),
>         ip: parts[4],
>         port: parseInt(parts[5], 10),
>         // skip parts[6] == 'typ'
>         type: parts[7]
>       };
> 
>       for (var i = 8; i < parts.length; i += 2) {
>         switch (parts[i]) {
>           case 'raddr':
>             candidate.relatedAddress = parts[i + 1];
>             break;
>           case 'rport':
>             candidate.relatedPort = parseInt(parts[i + 1], 10);
>             break;
>           case 'tcptype':
>             candidate.tcpType = parts[i + 1];
>             break;
>           default: // Unknown extensions are silently ignored.
>             break;
>         }
>       }
>       return candidate;
>     };
> 
>     // Translates a candidate object into SDP candidate attribute.
>     SDPUtils.writeCandidate = function(candidate) {
>       var sdp = [];
>       sdp.push(candidate.foundation);
>       sdp.push(candidate.component);
>       sdp.push(candidate.protocol.toUpperCase());
>       sdp.push(candidate.priority);
>       sdp.push(candidate.ip);
>       sdp.push(candidate.port);
> 
>       var type = candidate.type;
>       sdp.push('typ');
>       sdp.push(type);
>       if (type !== 'host' && candidate.relatedAddress &&
>           candidate.relatedPort) {
>         sdp.push('raddr');
>         sdp.push(candidate.relatedAddress); // was: relAddr
>         sdp.push('rport');
>         sdp.push(candidate.relatedPort); // was: relPort
>       }
>       if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
>         sdp.push('tcptype');
>         sdp.push(candidate.tcpType);
>       }
>       return 'candidate:' + sdp.join(' ');
>     };
> 
>     // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
>     // a=rtpmap:111 opus/48000/2
>     SDPUtils.parseRtpMap = function(line) {
>       var parts = line.substr(9).split(' ');
>       var parsed = {
>         payloadType: parseInt(parts.shift(), 10) // was: id
>       };
> 
>       parts = parts[0].split('/');
> 
>       parsed.name = parts[0];
>       parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
>       parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1; // was: channels
>       return parsed;
>     };
> 
>     // Generate an a=rtpmap line from RTCRtpCodecCapability or RTCRtpCodecParameters.
>     SDPUtils.writeRtpMap = function(codec) {
>       var pt = codec.payloadType;
>       if (codec.preferredPayloadType !== undefined) {
>         pt = codec.preferredPayloadType;
>       }
>       return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
>           (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
>     };
> 
>     // Parses an ftmp line, returns dictionary. Sample input:
>     // a=fmtp:96 vbr=on;cng=on
>     // Also deals with vbr=on; cng=on
>     SDPUtils.parseFmtp = function(line) {
>       var parsed = {};
>       var kv;
>       var parts = line.substr(line.indexOf(' ') + 1).split(';');
>       for (var j = 0; j < parts.length; j++) {
>         kv = parts[j].trim().split('=');
>         parsed[kv[0].trim()] = kv[1];
>       }
>       return parsed;
>     };
> 
>     // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
>     SDPUtils.writeFtmp = function(codec) {
>       var line = '';
>       var pt = codec.payloadType;
>       if (codec.preferredPayloadType !== undefined) {
>         pt = codec.preferredPayloadType;
>       }
>       if (codec.parameters && codec.parameters.length) {
>         var params = [];
>         Object.keys(codec.parameters).forEach(function(param) {
>           params.push(param + '=' + codec.parameters[param]);
>         });
>         line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
>       }
>       return line;
>     };
> 
>     // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
>     // a=rtcp-fb:98 nack rpsi
>     SDPUtils.parseRtcpFb = function(line) {
>       var parts = line.substr(line.indexOf(' ') + 1).split(' ');
>       return {
>         type: parts.shift(),
>         parameter: parts.join(' ')
>       };
>     };
>     // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
>     SDPUtils.writeRtcpFb = function(codec) {
>       var lines = '';
>       var pt = codec.payloadType;
>       if (codec.preferredPayloadType !== undefined) {
>         pt = codec.preferredPayloadType;
>       }
>       if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
>         // FIXME: special handling for trr-int?
>         codec.rtcpFeedback.forEach(function(fb) {
>           lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + ' ' + fb.parameter +
>               '\r\n';
>         });
>       }
>       return lines;
121,125c708,1143
<     // The representation of tracks in a stream is changed in M26.
<     // Unify them for earlier Chrome versions in the coexisting period.
<     if (!webkitMediaStream.prototype.getVideoTracks) {
<         webkitMediaStream.prototype.getVideoTracks = function() {
<             return this.videoTracks;
---
> 
>     // Parses an RFC 5576 ssrc media attribute. Sample input:
>     // a=ssrc:3735928559 cname:something
>     SDPUtils.parseSsrcMedia = function(line) {
>       var sp = line.indexOf(' ');
>       var parts = {
>         ssrc: line.substr(7, sp - 7),
>       };
>       var colon = line.indexOf(':', sp);
>       if (colon > -1) {
>         parts.attribute = line.substr(sp + 1, colon - sp - 1);
>         parts.value = line.substr(colon + 1);
>       } else {
>         parts.attribute = line.substr(sp + 1);
>       }
>       return parts;
>     };
> 
>     // Extracts DTLS parameters from SDP media section or sessionpart.
>     // FIXME: for consistency with other functions this should only
>     //   get the fingerprint line as input. See also getIceParameters.
>     SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
>       var lines = SDPUtils.splitLines(mediaSection);
>       lines = lines.concat(SDPUtils.splitLines(sessionpart)); // Search in session part, too.
>       var fpLine = lines.filter(function(line) {
>         return line.indexOf('a=fingerprint:') === 0;
>       })[0].substr(14);
>       // Note: a=setup line is ignored since we use the 'auto' role.
>       var dtlsParameters = {
>         role: 'auto',
>         fingerprints: [{
>           algorithm: fpLine.split(' ')[0],
>           value: fpLine.split(' ')[1]
>         }]
>       };
>       return dtlsParameters;
>     };
> 
>     // Serializes DTLS parameters to SDP.
>     SDPUtils.writeDtlsParameters = function(params, setupType) {
>       var sdp = 'a=setup:' + setupType + '\r\n';
>       params.fingerprints.forEach(function(fp) {
>         sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
>       });
>       return sdp;
>     };
>     // Parses ICE information from SDP media section or sessionpart.
>     // FIXME: for consistency with other functions this should only
>     //   get the ice-ufrag and ice-pwd lines as input.
>     SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
>       var lines = SDPUtils.splitLines(mediaSection);
>       lines = lines.concat(SDPUtils.splitLines(sessionpart)); // Search in session part, too.
>       var iceParameters = {
>         usernameFragment: lines.filter(function(line) {
>           return line.indexOf('a=ice-ufrag:') === 0;
>         })[0].substr(12),
>         password: lines.filter(function(line) {
>           return line.indexOf('a=ice-pwd:') === 0;
>         })[0].substr(10)
>       };
>       return iceParameters;
>     };
> 
>     // Serializes ICE parameters to SDP.
>     SDPUtils.writeIceParameters = function(params) {
>       return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
>           'a=ice-pwd:' + params.password + '\r\n';
>     };
> 
>     // Parses the SDP media section and returns RTCRtpParameters.
>     SDPUtils.parseRtpParameters = function(mediaSection) {
>       var description = {
>         codecs: [],
>         headerExtensions: [],
>         fecMechanisms: [],
>         rtcp: []
>       };
>       var lines = SDPUtils.splitLines(mediaSection);
>       var mline = lines[0].split(' ');
>       for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
>         var pt = mline[i];
>         var rtpmapline = SDPUtils.matchPrefix(
>             mediaSection, 'a=rtpmap:' + pt + ' ')[0];
>         if (rtpmapline) {
>           var codec = SDPUtils.parseRtpMap(rtpmapline);
>           var fmtps = SDPUtils.matchPrefix(
>               mediaSection, 'a=fmtp:' + pt + ' ');
>           // Only the first a=fmtp:<pt> is considered.
>           codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
>           codec.rtcpFeedback = SDPUtils.matchPrefix(
>               mediaSection, 'a=rtcp-fb:' + pt + ' ')
>             .map(SDPUtils.parseRtcpFb);
>           description.codecs.push(codec);
>         }
>       }
>       // FIXME: parse headerExtensions, fecMechanisms and rtcp.
>       return description;
>     };
> 
>     // Generates parts of the SDP media section describing the capabilities / parameters.
>     SDPUtils.writeRtpDescription = function(kind, caps) {
>       var sdp = '';
> 
>       // Build the mline.
>       sdp += 'm=' + kind + ' ';
>       sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
>       sdp += ' UDP/TLS/RTP/SAVPF ';
>       sdp += caps.codecs.map(function(codec) {
>         if (codec.preferredPayloadType !== undefined) {
>           return codec.preferredPayloadType;
>         }
>         return codec.payloadType;
>       }).join(' ') + '\r\n';
> 
>       sdp += 'c=IN IP4 0.0.0.0\r\n';
>       sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';
> 
>       // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
>       caps.codecs.forEach(function(codec) {
>         sdp += SDPUtils.writeRtpMap(codec);
>         sdp += SDPUtils.writeFtmp(codec);
>         sdp += SDPUtils.writeRtcpFb(codec);
>       });
>       // FIXME: add headerExtensions, fecMechanismş and rtcp.
>       sdp += 'a=rtcp-mux\r\n';
>       return sdp;
>     };
> 
>     SDPUtils.writeSessionBoilerplate = function() {
>       // FIXME: sess-id should be an NTP timestamp.
>       return 'v=0\r\n' +
>           'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\n' +
>           's=-\r\n' +
>           't=0 0\r\n';
>     };
> 
>     SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
>       var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);
> 
>       // Map ICE parameters (ufrag, pwd) to SDP.
>       sdp += SDPUtils.writeIceParameters(
>           transceiver.iceGatherer.getLocalParameters());
> 
>       // Map DTLS parameters to SDP.
>       sdp += SDPUtils.writeDtlsParameters(
>           transceiver.dtlsTransport.getLocalParameters(),
>           type === 'offer' ? 'actpass' : 'active');
> 
>       sdp += 'a=mid:' + transceiver.mid + '\r\n';
> 
>       if (transceiver.rtpSender && transceiver.rtpReceiver) {
>         sdp += 'a=sendrecv\r\n';
>       } else if (transceiver.rtpSender) {
>         sdp += 'a=sendonly\r\n';
>       } else if (transceiver.rtpReceiver) {
>         sdp += 'a=recvonly\r\n';
>       } else {
>         sdp += 'a=inactive\r\n';
>       }
> 
>       // FIXME: for RTX there might be multiple SSRCs. Not implemented in Edge yet.
>       if (transceiver.rtpSender) {
>         var msid = 'msid:' + stream.id + ' ' +
>             transceiver.rtpSender.track.id + '\r\n';
>         sdp += 'a=' + msid;
>         sdp += 'a=ssrc:' + transceiver.sendSsrc + ' ' + msid;
>       }
>       // FIXME: this should be written by writeRtpDescription.
>       sdp += 'a=ssrc:' + transceiver.sendSsrc + ' cname:' +
>           localCName + '\r\n';
>       return sdp;
>     };
> 
>     // Gets the direction from the mediaSection or the sessionpart.
>     SDPUtils.getDirection = function(mediaSection, sessionpart) {
>       // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
>       var lines = SDPUtils.splitLines(mediaSection);
>       for (var i = 0; i < lines.length; i++) {
>         switch (lines[i]) {
>           case 'a=sendrecv':
>           case 'a=sendonly':
>           case 'a=recvonly':
>           case 'a=inactive':
>             return lines[i].substr(2);
>         }
>       }
>       if (sessionpart) {
>         return SDPUtils.getDirection(sessionpart);
>       }
>       return 'sendrecv';
>     };
> 
>     // ORTC defines an RTCIceCandidate object but no constructor.
>     // Not implemented in Edge.
>     if (!window.RTCIceCandidate) {
>       window.RTCIceCandidate = function(args) {
>         return args;
>       };
>     }
>     // ORTC does not have a session description object but
>     // other browsers (i.e. Chrome) that will support both PC and ORTC
>     // in the future might have this defined already.
>     if (!window.RTCSessionDescription) {
>       window.RTCSessionDescription = function(args) {
>         return args;
>       };
>     }
> 
>     window.RTCPeerConnection = function(config) {
>       var self = this;
> 
>       this.onicecandidate = null;
>       this.onaddstream = null;
>       this.onremovestream = null;
>       this.onsignalingstatechange = null;
>       this.oniceconnectionstatechange = null;
>       this.onnegotiationneeded = null;
>       this.ondatachannel = null;
> 
>       this.localStreams = [];
>       this.remoteStreams = [];
>       this.getLocalStreams = function() { return self.localStreams; };
>       this.getRemoteStreams = function() { return self.remoteStreams; };
> 
>       this.localDescription = new RTCSessionDescription({
>         type: '',
>         sdp: ''
>       });
>       this.remoteDescription = new RTCSessionDescription({
>         type: '',
>         sdp: ''
>       });
>       this.signalingState = 'stable';
>       this.iceConnectionState = 'new';
> 
>       this.iceOptions = {
>         gatherPolicy: 'all',
>         iceServers: []
>       };
>       if (config && config.iceTransportPolicy) {
>         switch (config.iceTransportPolicy) {
>           case 'all':
>           case 'relay':
>             this.iceOptions.gatherPolicy = config.iceTransportPolicy;
>             break;
>           case 'none':
>             // FIXME: remove once implementation and spec have added this.
>             throw new TypeError('iceTransportPolicy "none" not supported');
>         }
>       }
>       if (config && config.iceServers) {
>         // Edge does not like
>         // 1) stun:
>         // 2) turn: that does not have all of turn:host:port?transport=udp
>         // 3) an array of urls
>         config.iceServers.forEach(function(server) {
>           if (server.urls) {
>             var url;
>             if (typeof(server.urls) === 'string') {
>               url = server.urls;
>             } else {
>               url = server.urls[0];
>             }
>             if (url.indexOf('transport=udp') !== -1) {
>               self.iceServers.push({
>                 username: server.username,
>                 credential: server.credential,
>                 urls: url
>               });
>             }
>           }
>         });
>       }
> 
>       // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
>       // everything that is needed to describe a SDP m-line.
>       this.transceivers = [];
> 
>       // since the iceGatherer is currently created in createOffer but we
>       // must not emit candidates until after setLocalDescription we buffer
>       // them in this array.
>       this._localIceCandidatesBuffer = [];
>     };
> 
>     window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
>       var self = this;
>       // FIXME: need to apply ice candidates in a way which is async but in-order
>       this._localIceCandidatesBuffer.forEach(function(event) {
>         if (self.onicecandidate !== null) {
>           self.onicecandidate(event);
>         }
>       });
>       this._localIceCandidatesBuffer = [];
>     };
> 
>     window.RTCPeerConnection.prototype.addStream = function(stream) {
>       // Clone is necessary for local demos mostly, attaching directly
>       // to two different senders does not work (build 10547).
>       this.localStreams.push(stream.clone());
>       this._maybeFireNegotiationNeeded();
>     };
> 
>     window.RTCPeerConnection.prototype.removeStream = function(stream) {
>       var idx = this.localStreams.indexOf(stream);
>       if (idx > -1) {
>         this.localStreams.splice(idx, 1);
>         this._maybeFireNegotiationNeeded();
>       }
>     };
> 
>     // Determines the intersection of local and remote capabilities.
>     window.RTCPeerConnection.prototype._getCommonCapabilities =
>         function(localCapabilities, remoteCapabilities) {
>       var commonCapabilities = {
>         codecs: [],
>         headerExtensions: [],
>         fecMechanisms: []
>       };
>       localCapabilities.codecs.forEach(function(lCodec) {
>         for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
>           var rCodec = remoteCapabilities.codecs[i];
>           if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
>               lCodec.clockRate === rCodec.clockRate &&
>               lCodec.numChannels === rCodec.numChannels) {
>             // push rCodec so we reply with offerer payload type
>             commonCapabilities.codecs.push(rCodec);
> 
>             // FIXME: also need to determine intersection between
>             // .rtcpFeedback and .parameters
>             break;
>           }
>         }
>       });
> 
>       localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
>         for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
>           var rHeaderExtension = remoteCapabilities.headerExtensions[i];
>           if (lHeaderExtension.uri === rHeaderExtension.uri) {
>             commonCapabilities.headerExtensions.push(rHeaderExtension);
>             break;
>           }
>         }
>       });
> 
>       // FIXME: fecMechanisms
>       return commonCapabilities;
>     };
> 
>     // Create ICE gatherer, ICE transport and DTLS transport.
>     window.RTCPeerConnection.prototype._createIceAndDtlsTransports =
>         function(mid, sdpMLineIndex) {
>       var self = this;
>       var iceGatherer = new RTCIceGatherer(self.iceOptions);
>       var iceTransport = new RTCIceTransport(iceGatherer);
>       iceGatherer.onlocalcandidate = function(evt) {
>         var event = {};
>         event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};
> 
>         var cand = evt.candidate;
>         // Edge emits an empty object for RTCIceCandidateComplete‥
>         if (!cand || Object.keys(cand).length === 0) {
>           // polyfill since RTCIceGatherer.state is not implemented in Edge 10547 yet.
>           if (iceGatherer.state === undefined) {
>             iceGatherer.state = 'completed';
>           }
> 
>           // Emit a candidate with type endOfCandidates to make the samples work.
>           // Edge requires addIceCandidate with this empty candidate to start checking.
>           // The real solution is to signal end-of-candidates to the other side when
>           // getting the null candidate but some apps (like the samples) don't do that.
>           event.candidate.candidate =
>               'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';
>         } else {
>           // RTCIceCandidate doesn't have a component, needs to be added
>           cand.component = iceTransport.component === 'RTCP' ? 2 : 1;
>           event.candidate.candidate = SDPUtils.writeCandidate(cand);
>         }
> 
>         var complete = self.transceivers.every(function(transceiver) {
>           return transceiver.iceGatherer &&
>               transceiver.iceGatherer.state === 'completed';
>         });
>         // FIXME: update .localDescription with candidate and (potentially) end-of-candidates.
>         //     To make this harder, the gatherer might emit candidates before localdescription
>         //     is set. To make things worse, gather.getLocalCandidates still errors in
>         //     Edge 10547 when no candidates have been gathered yet.
> 
>         if (self.onicecandidate !== null) {
>           // Emit candidate if localDescription is set.
>           // Also emits null candidate when all gatherers are complete.
>           if (self.localDescription && self.localDescription.type === '') {
>             self._localIceCandidatesBuffer.push(event);
>             if (complete) {
>               self._localIceCandidatesBuffer.push({});
>             }
>           } else {
>             self.onicecandidate(event);
>             if (complete) {
>               self.onicecandidate({});
>             }
>           }
>         }
>       };
>       iceTransport.onicestatechange = function() {
>         self._updateConnectionState();
>       };
> 
>       var dtlsTransport = new RTCDtlsTransport(iceTransport);
>       dtlsTransport.ondtlsstatechange = function() {
>         self._updateConnectionState();
>       };
>       dtlsTransport.onerror = function() {
>         // onerror does not set state to failed by itself.
>         dtlsTransport.state = 'failed';
>         self._updateConnectionState();
>       };
> 
>       return {
>         iceGatherer: iceGatherer,
>         iceTransport: iceTransport,
>         dtlsTransport: dtlsTransport
>       };
>     };
> 
>     // Start the RTP Sender and Receiver for a transceiver.
>     window.RTCPeerConnection.prototype._transceive = function(transceiver,
>         send, recv) {
>       var params = this._getCommonCapabilities(transceiver.localCapabilities,
>           transceiver.remoteCapabilities);
>       if (send && transceiver.rtpSender) {
>         params.encodings = [{
>           ssrc: transceiver.sendSsrc
>         }];
>         params.rtcp = {
>           cname: localCName,
>           ssrc: transceiver.recvSsrc
127,128c1145,1153
<         webkitMediaStream.prototype.getAudioTracks = function() {
<             return this.audioTracks;
---
>         transceiver.rtpSender.send(params);
>       }
>       if (recv && transceiver.rtpReceiver) {
>         params.encodings = [{
>           ssrc: transceiver.recvSsrc
>         }];
>         params.rtcp = {
>           cname: transceiver.cname,
>           ssrc: transceiver.sendSsrc
130c1155,1157
<     }
---
>         transceiver.rtpReceiver.receive(params);
>       }
>     };
132,138c1159,1567
< // New syntax of getXXXStreams method in M26.
<     if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
<         webkitRTCPeerConnection.prototype.getLocalStreams = function() {
<             return this.localStreams;
<         };
<         webkitRTCPeerConnection.prototype.getRemoteStreams = function() {
<             return this.remoteStreams;
---
>     window.RTCPeerConnection.prototype.setLocalDescription =
>         function(description) {
>       var self = this;
>       if (description.type === 'offer') {
>         if (this._pendingOffer) {
>           this.transceivers = this._pendingOffer;
>           delete this._pendingOffer;
>         }
>       } else if (description.type === 'answer') {
>         var sections = SDPUtils.splitSections(self.remoteDescription.sdp);
>         var sessionpart = sections.shift();
>         sections.forEach(function(mediaSection, sdpMLineIndex) {
>           var transceiver = self.transceivers[sdpMLineIndex];
>           var iceGatherer = transceiver.iceGatherer;
>           var iceTransport = transceiver.iceTransport;
>           var dtlsTransport = transceiver.dtlsTransport;
>           var localCapabilities = transceiver.localCapabilities;
>           var remoteCapabilities = transceiver.remoteCapabilities;
>           var rejected = mediaSection.split('\n', 1)[0]
>               .split(' ', 2)[1] === '0';
> 
>           if (!rejected) {
>             var remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
>                 sessionpart);
>             iceTransport.start(iceGatherer, remoteIceParameters, 'controlled');
> 
>             var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
>               sessionpart);
>             dtlsTransport.start(remoteDtlsParameters);
> 
>             // Calculate intersection of capabilities.
>             var params = self._getCommonCapabilities(localCapabilities,
>                 remoteCapabilities);
> 
>             // Start the RTCRtpSender. The RTCRtpReceiver for this transceiver
>             // has already been started in setRemoteDescription.
>             self._transceive(transceiver,
>                 params.codecs.length > 0,
>                 false);
>           }
>         });
>       }
> 
>       this.localDescription = description;
>       switch (description.type) {
>         case 'offer':
>           this._updateSignalingState('have-local-offer');
>           break;
>         case 'answer':
>           this._updateSignalingState('stable');
>           break;
>         default:
>           throw new TypeError('unsupported type "' + description.type + '"');
>       }
> 
>       // If a success callback was provided, emit ICE candidates after it has been
>       // executed. Otherwise, emit callback after the Promise is resolved.
>       var hasCallback = arguments.length > 1 &&
>         typeof arguments[1] === 'function';
>       if (hasCallback) {
>         var cb = arguments[1];
>         window.setTimeout(function() {
>           cb();
>           self._emitBufferedCandidates();
>         }, 0);
>       }
>       var p = Promise.resolve();
>       p.then(function() {
>         if (!hasCallback) {
>           window.setTimeout(self._emitBufferedCandidates.bind(self), 0);
>         }
>       });
>       return p;
>     };
> 
>     window.RTCPeerConnection.prototype.setRemoteDescription =
>         function(description) {
>       var self = this;
>       var stream = new MediaStream();
>       var sections = SDPUtils.splitSections(description.sdp);
>       var sessionpart = sections.shift();
>       sections.forEach(function(mediaSection, sdpMLineIndex) {
>         var lines = SDPUtils.splitLines(mediaSection);
>         var mline = lines[0].substr(2).split(' ');
>         var kind = mline[0];
>         var rejected = mline[1] === '0';
>         var direction = SDPUtils.getDirection(mediaSection, sessionpart);
> 
>         var transceiver;
>         var iceGatherer;
>         var iceTransport;
>         var dtlsTransport;
>         var rtpSender;
>         var rtpReceiver;
>         var sendSsrc;
>         var recvSsrc;
>         var localCapabilities;
> 
>         // FIXME: ensure the mediaSection has rtcp-mux set.
>         var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
>         var remoteIceParameters;
>         var remoteDtlsParameters;
>         if (!rejected) {
>           remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
>               sessionpart);
>           remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
>               sessionpart);
>         }
>         var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0].substr(6);
> 
>         var cname;
>         // Gets the first SSRC. Note that with RTX there might be multiple SSRCs.
>         var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
>             .map(function(line) {
>               return SDPUtils.parseSsrcMedia(line);
>             })
>             .filter(function(obj) {
>               return obj.attribute === 'cname';
>             })[0];
>         if (remoteSsrc) {
>           recvSsrc = parseInt(remoteSsrc.ssrc, 10);
>           cname = remoteSsrc.value;
>         }
> 
>         if (description.type === 'offer') {
>           var transports = self._createIceAndDtlsTransports(mid, sdpMLineIndex);
> 
>           localCapabilities = RTCRtpReceiver.getCapabilities(kind);
>           sendSsrc = (2 * sdpMLineIndex + 2) * 1001;
> 
>           rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
> 
>           // FIXME: not correct when there are multiple streams but that is
>           // not currently supported in this shim.
>           stream.addTrack(rtpReceiver.track);
> 
>           // FIXME: look at direction.
>           if (self.localStreams.length > 0 &&
>               self.localStreams[0].getTracks().length >= sdpMLineIndex) {
>             // FIXME: actually more complicated, needs to match types etc
>             var localtrack = self.localStreams[0].getTracks()[sdpMLineIndex];
>             rtpSender = new RTCRtpSender(localtrack, transports.dtlsTransport);
>           }
> 
>           self.transceivers[sdpMLineIndex] = {
>             iceGatherer: transports.iceGatherer,
>             iceTransport: transports.iceTransport,
>             dtlsTransport: transports.dtlsTransport,
>             localCapabilities: localCapabilities,
>             remoteCapabilities: remoteCapabilities,
>             rtpSender: rtpSender,
>             rtpReceiver: rtpReceiver,
>             kind: kind,
>             mid: mid,
>             cname: cname,
>             sendSsrc: sendSsrc,
>             recvSsrc: recvSsrc
>           };
>           // Start the RTCRtpReceiver now. The RTPSender is started in setLocalDescription.
>           self._transceive(self.transceivers[sdpMLineIndex],
>               false,
>               direction === 'sendrecv' || direction === 'sendonly');
>         } else if (description.type === 'answer' && !rejected) {
>           transceiver = self.transceivers[sdpMLineIndex];
>           iceGatherer = transceiver.iceGatherer;
>           iceTransport = transceiver.iceTransport;
>           dtlsTransport = transceiver.dtlsTransport;
>           rtpSender = transceiver.rtpSender;
>           rtpReceiver = transceiver.rtpReceiver;
>           sendSsrc = transceiver.sendSsrc;
>           //recvSsrc = transceiver.recvSsrc;
>           localCapabilities = transceiver.localCapabilities;
> 
>           self.transceivers[sdpMLineIndex].recvSsrc = recvSsrc;
>           self.transceivers[sdpMLineIndex].remoteCapabilities =
>               remoteCapabilities;
>           self.transceivers[sdpMLineIndex].cname = cname;
> 
>           iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');
>           dtlsTransport.start(remoteDtlsParameters);
> 
>           self._transceive(transceiver,
>               direction === 'sendrecv' || direction === 'recvonly',
>               direction === 'sendrecv' || direction === 'sendonly');
> 
>           if (rtpReceiver &&
>               (direction === 'sendrecv' || direction === 'sendonly')) {
>             stream.addTrack(rtpReceiver.track);
>           } else {
>             // FIXME: actually the receiver should be created later.
>             delete transceiver.rtpReceiver;
>           }
>         }
>       });
> 
>       this.remoteDescription = description;
>       switch (description.type) {
>         case 'offer':
>           this._updateSignalingState('have-remote-offer');
>           break;
>         case 'answer':
>           this._updateSignalingState('stable');
>           break;
>         default:
>           throw new TypeError('unsupported type "' + description.type + '"');
>       }
>       window.setTimeout(function() {
>         if (self.onaddstream !== null && stream.getTracks().length) {
>           self.remoteStreams.push(stream);
>           window.setTimeout(function() {
>             self.onaddstream({stream: stream});
>           }, 0);
>         }
>       }, 0);
>       if (arguments.length > 1 && typeof arguments[1] === 'function') {
>         window.setTimeout(arguments[1], 0);
>       }
>       return Promise.resolve();
>     };
> 
>     window.RTCPeerConnection.prototype.close = function() {
>       this.transceivers.forEach(function(transceiver) {
>         /* not yet
>         if (transceiver.iceGatherer) {
>           transceiver.iceGatherer.close();
>         }
>         */
>         if (transceiver.iceTransport) {
>           transceiver.iceTransport.stop();
>         }
>         if (transceiver.dtlsTransport) {
>           transceiver.dtlsTransport.stop();
>         }
>         if (transceiver.rtpSender) {
>           transceiver.rtpSender.stop();
>         }
>         if (transceiver.rtpReceiver) {
>           transceiver.rtpReceiver.stop();
>         }
>       });
>       // FIXME: clean up tracks, local streams, remote streams, etc
>       this._updateSignalingState('closed');
>     };
> 
>     // Update the signaling state.
>     window.RTCPeerConnection.prototype._updateSignalingState =
>         function(newState) {
>       this.signalingState = newState;
>       if (this.onsignalingstatechange !== null) {
>         this.onsignalingstatechange();
>       }
>     };
> 
>     // Determine whether to fire the negotiationneeded event.
>     window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
>         function() {
>       // Fire away (for now).
>       if (this.onnegotiationneeded !== null) {
>         this.onnegotiationneeded();
>       }
>     };
> 
>     // Update the connection state.
>     window.RTCPeerConnection.prototype._updateConnectionState =
>         function() {
>       var self = this;
>       var newState;
>       var states = {
>         'new': 0,
>         closed: 0,
>         connecting: 0,
>         checking: 0,
>         connected: 0,
>         completed: 0,
>         failed: 0
>       };
>       this.transceivers.forEach(function(transceiver) {
>         states[transceiver.iceTransport.state]++;
>         states[transceiver.dtlsTransport.state]++;
>       });
>       // ICETransport.completed and connected are the same for this purpose.
>       states.connected += states.completed;
> 
>       newState = 'new';
>       if (states.failed > 0) {
>         newState = 'failed';
>       } else if (states.connecting > 0 || states.checking > 0) {
>         newState = 'connecting';
>       } else if (states.disconnected > 0) {
>         newState = 'disconnected';
>       } else if (states.new > 0) {
>         newState = 'new';
>       } else if (states.connecting > 0 || states.completed > 0) {
>         newState = 'connected';
>       }
> 
>       if (newState !== self.iceConnectionState) {
>         self.iceConnectionState = newState;
>         if (this.oniceconnectionstatechange !== null) {
>           this.oniceconnectionstatechange();
>         }
>       }
>     };
> 
>     window.RTCPeerConnection.prototype.createOffer = function() {
>       var self = this;
>       if (this._pendingOffer) {
>         throw new Error('createOffer called while there is a pending offer.');
>       }
>       var offerOptions;
>       if (arguments.length === 1 && typeof arguments[0] !== 'function') {
>         offerOptions = arguments[0];
>       } else if (arguments.length === 3) {
>         offerOptions = arguments[2];
>       }
> 
>       var tracks = [];
>       var numAudioTracks = 0;
>       var numVideoTracks = 0;
>       // Default to sendrecv.
>       if (this.localStreams.length) {
>         numAudioTracks = this.localStreams[0].getAudioTracks().length;
>         numVideoTracks = this.localStreams[0].getVideoTracks().length;
>       }
>       // Determine number of audio and video tracks we need to send/recv.
>       if (offerOptions) {
>         // Reject Chrome legacy constraints.
>         if (offerOptions.mandatory || offerOptions.optional) {
>           throw new TypeError(
>               'Legacy mandatory/optional constraints not supported.');
>         }
>         if (offerOptions.offerToReceiveAudio !== undefined) {
>           numAudioTracks = offerOptions.offerToReceiveAudio;
>         }
>         if (offerOptions.offerToReceiveVideo !== undefined) {
>           numVideoTracks = offerOptions.offerToReceiveVideo;
>         }
>       }
>       if (this.localStreams.length) {
>         // Push local streams.
>         this.localStreams[0].getTracks().forEach(function(track) {
>           tracks.push({
>             kind: track.kind,
>             track: track,
>             wantReceive: track.kind === 'audio' ?
>                 numAudioTracks > 0 : numVideoTracks > 0
>           });
>           if (track.kind === 'audio') {
>             numAudioTracks--;
>           } else if (track.kind === 'video') {
>             numVideoTracks--;
>           }
>         });
>       }
>       // Create M-lines for recvonly streams.
>       while (numAudioTracks > 0 || numVideoTracks > 0) {
>         if (numAudioTracks > 0) {
>           tracks.push({
>             kind: 'audio',
>             wantReceive: true
>           });
>           numAudioTracks--;
>         }
>         if (numVideoTracks > 0) {
>           tracks.push({
>             kind: 'video',
>             wantReceive: true
>           });
>           numVideoTracks--;
>         }
>       }
> 
>       var sdp = SDPUtils.writeSessionBoilerplate();
>       var transceivers = [];
>       tracks.forEach(function(mline, sdpMLineIndex) {
>         // For each track, create an ice gatherer, ice transport, dtls transport,
>         // potentially rtpsender and rtpreceiver.
>         var track = mline.track;
>         var kind = mline.kind;
>         var mid = generateIdentifier();
> 
>         var transports = self._createIceAndDtlsTransports(mid, sdpMLineIndex);
> 
>         var localCapabilities = RTCRtpSender.getCapabilities(kind);
>         var rtpSender;
>         var rtpReceiver;
> 
>         // generate an ssrc now, to be used later in rtpSender.send
>         var sendSsrc = (2 * sdpMLineIndex + 1) * 1001;
>         if (track) {
>           rtpSender = new RTCRtpSender(track, transports.dtlsTransport);
>         }
> 
>         if (mline.wantReceive) {
>           rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
>         }
> 
>         transceivers[sdpMLineIndex] = {
>           iceGatherer: transports.iceGatherer,
>           iceTransport: transports.iceTransport,
>           dtlsTransport: transports.dtlsTransport,
>           localCapabilities: localCapabilities,
>           remoteCapabilities: null,
>           rtpSender: rtpSender,
>           rtpReceiver: rtpReceiver,
>           kind: kind,
>           mid: mid,
>           sendSsrc: sendSsrc,
>           recvSsrc: null
140,175c1569,1676
<     }
< //} else if( window.ActiveXObject ){ // appears to IE so check for the wrapper.
< //    var head = document.getElementsByTagName('head')[0];
< //    var i;
< //    var adapterAddress;
< //    var wrapperPresent = false;
< //
< //    //
< //    // we look for the adapter as well as the wrapper because if we don't find the
< //    // wrapper, we'll look for it in the same directory as the adapter was found.
< //    //
< //    for( i = 0; i < head.childNodes.length; i++) {
< //        var child = head.childNodes[i];
< //        if( /\/adapter.js$/.test(child.src)) {
< //            adapterAddress = child.src;
< //        }
< //        else if( /\/rtcplugin.js$/.test(child.src)) {
< //            wrapperPresent = true;
< //        }
< //    }
< //
< //
< //    if( wrapperPresent) {
< //        addIEDeclarations();
< //    }
< //    else if( adapterAddress) {
< //        var script = document.createElement('script');
< //        script.type = 'text/javascript';
< //        script.src = adapterAddress.replace(/\/adapter.js$/, "/rtcplugin.js");
< //        src.onload = addIEDeclarations;
< //        src.onerror = function () {
< //            alert("Developer error: this page requires the Priologic IE Webrtc plugin wrapper (rtcplugin.js) to run when using Internet Explorer, which the developer has not supplied.");
< //            throw new Error("No rtcplugin.js found. It should be in the same folder as your adapter.js or you can include it yourself before the adapter.js");
< //        }
< //        head.appendChild(script);
< //    }
---
>         var transceiver = transceivers[sdpMLineIndex];
>         sdp += SDPUtils.writeMediaSection(transceiver,
>             transceiver.localCapabilities, 'offer', self.localStreams[0]);
>       });
> 
>       this._pendingOffer = transceivers;
>       var desc = new RTCSessionDescription({
>         type: 'offer',
>         sdp: sdp
>       });
>       if (arguments.length && typeof arguments[0] === 'function') {
>         window.setTimeout(arguments[0], 0, desc);
>       }
>       return Promise.resolve(desc);
>     };
> 
>     window.RTCPeerConnection.prototype.createAnswer = function() {
>       var self = this;
>       var answerOptions;
>       if (arguments.length === 1 && typeof arguments[0] !== 'function') {
>         answerOptions = arguments[0];
>       } else if (arguments.length === 3) {
>         answerOptions = arguments[2];
>       }
> 
>       var sdp = SDPUtils.writeSessionBoilerplate();
>       this.transceivers.forEach(function(transceiver) {
>         // Calculate intersection of capabilities.
>         var commonCapabilities = self._getCommonCapabilities(
>             transceiver.localCapabilities,
>             transceiver.remoteCapabilities);
> 
>         sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
>             'answer', self.localStreams[0]);
>       });
> 
>       var desc = new RTCSessionDescription({
>         type: 'answer',
>         sdp: sdp
>       });
>       if (arguments.length && typeof arguments[0] === 'function') {
>         window.setTimeout(arguments[0], 0, desc);
>       }
>       return Promise.resolve(desc);
>     };
> 
>     window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
>       var mLineIndex = candidate.sdpMLineIndex;
>       if (candidate.sdpMid) {
>         for (var i = 0; i < this.transceivers.length; i++) {
>           if (this.transceivers[i].mid === candidate.sdpMid) {
>             mLineIndex = i;
>             break;
>           }
>         }
>       }
>       var transceiver = this.transceivers[mLineIndex];
>       if (transceiver) {
>         var cand = Object.keys(candidate.candidate).length > 0 ?
>             SDPUtils.parseCandidate(candidate.candidate) : {};
>         // Ignore Chrome's invalid candidates since Edge does not like them.
>         if (cand.protocol === 'tcp' && cand.port === 0) {
>           return;
>         }
>         // Ignore RTCP candidates, we assume RTCP-MUX.
>         if (cand.component !== '1') {
>           return;
>         }
>         // A dirty hack to make samples work.
>         if (cand.type === 'endOfCandidates') {
>           cand = {};
>         }
>         transceiver.iceTransport.addRemoteCandidate(cand);
>       }
>       if (arguments.length > 1 && typeof arguments[1] === 'function') {
>         window.setTimeout(arguments[1], 0);
>       }
>       return Promise.resolve();
>     };
> 
>     window.RTCPeerConnection.prototype.getStats = function() {
>       var promises = [];
>       this.transceivers.forEach(function(transceiver) {
>         ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
>             'dtlsTransport'].forEach(function(method) {
>           if (transceiver[method]) {
>             promises.push(transceiver[method].getStats());
>           }
>         });
>       });
>       var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
>           arguments[1];
>       return new Promise(function(resolve) {
>         var results = {};
>         Promise.all(promises).then(function(res) {
>           res.forEach(function(result) {
>             Object.keys(result).forEach(function(id) {
>               results[id] = result[id];
>             });
>           });
>           if (cb) {
>             window.setTimeout(cb, 0, results);
>           }
>           resolve(results);
>         });
>       });
>     };
>   }
177c1678
<     console.log("Browser does not appear to be WebRTC-capable");
---
>   webrtcUtils.log('Browser does not appear to be WebRTC-capable');
180,185c1681,1712
< if (!window.createIceServer) {
<     window.createIceServer = function(url, username, credential) {
<         return {'url': url, 'credential': credential, 'username': username};
<     };
< }/** @class
<  *@version 1.0.15
---
> // Polyfill ontrack on browsers that don't yet have it
> if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection)) {
>   Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
>     get: function() { return this._ontrack; },
>     set: function(f) {
>       if (this._ontrack) {
>         this.removeEventListener('track', this._ontrack);
>         this.removeEventListener('addstream', this._ontrackpoly);
>       }
>       this.addEventListener('track', this._ontrack = f);
>       this.addEventListener('addstream', this._ontrackpoly = function(e) {
>         e.stream.getTracks().forEach(function(track) {
>           var event = new Event('track');
>           event.track = track;
>           event.receiver = {track: track};
>           event.streams = [e.stream];
>           this.dispatchEvent(event);
>         }.bind(this));
>       }.bind(this));
>     }
>   });
> }
> 
> var webrtcTesting = {};
> try {
>   Object.defineProperty(webrtcTesting, 'version', {
>     set: function(version) {
>       webrtcDetectedVersion = version;
>     }
>   });
> } catch (e) {}/** @class
>  *@version 1.0.17
220a1748,1752
> /* global getUserMedia, MediaStreamTrack, createIceServer, RTCIceCandidate, RTCPeerConnection, RTCSessionDescription */ // WebRTC
> /* global webrtcDetectedBrowser, webrtcDetectedVersion, attachMediaStream , webrtcUtils*/ // adapter.js
> /* global easyrtc_constantStrings */ // easyrtc_lang_en.js
> /* global io */
> 
221a1754,1767
> 
>     function isEmptyObj(obj) {
>         if (obj === null || obj === undefined) {
>             return true;
>         }
>         var key;
>         for (key in obj) {
>             if (obj.hasOwnProperty(key)) {
>                 return false;
>             }
>         }
>         return true;
>     }
>     
223c1769,1770
<     var isFirefox = (webrtcDetectedBrowser === "firefox");
---
>     
>     /** @private */
225,226c1772,1776
<     var sdpLocalFilter = null,
<             sdpRemoteFilter = null;
---
>     /** @private */
>     var sdpLocalFilter = null;
>     /** @private */
>     var sdpRemoteFilter = null;
>     /** @private */
228c1778,1780
< 
---
>     /** @private */
>     var iceConnectionStateChangeListener = null;
>     /** @private */
230,232c1782,1784
<                 'connect timeout': 10000,
<                 'force new connection': true
<             };
---
>         'connect timeout': 10000,
>         'force new connection': true
>     };  
233a1786
>     /** @private */
239a1793
> 
251a1806,1811
> 
>        if (typeof stream.stop === 'function') {
>            try {
>              stream.stop();
>            } catch(err){}
>        }
266,299c1826,1871
<    /**
<     * Sets a function to warn about the peer connection closing.
<     *  @param {Function} handler: a function that gets an easyrtcid as an argument.
<     */
<    this.setPeerClosedListener = function( handler ) {
<       this.onPeerClosed = handler;
<    };
< 
<    /**
<     * Sets a function to receive warnings about the peer connection
<     * failing. The peer connection may recover by itself.
<     *  @param {Function} failingHandler: a function that gets an easyrtcid as an argument.
<     *  @param {Function} recoveredHandler: a function that gets an easyrtcid as an argument.
<     */
<    this.setPeerFailingListener = function( failingHandler, recoveredHandler ) {
<       this.onPeerFailing = failingHandler;
<       this.onPeerRecovered = recoveredHandler;
<    };
< 
<    /**
<     * Sets a function which filters IceCandidate records being sent or received.
<     *
<     * Candidate records can be received while they are being generated locally (before being
<     * sent to a peer), and after they are received by the peer. The filter receives two arguments, the candidate record and a boolean
<     * flag that is true for a candidate being received from another peer,
<     * and false for a candidate that was generated locally. The candidate record has the form:
<     *  {type: 'candidate', label: sdpMLineIndex, id: sdpMid, candidate: candidateString}
<     * The function should return one of the following: the input candidate record, a modified candidate record, or null (indicating that the
<     * candidate should be discarded).
<     * @param {Function} filter
<     */
<    this.setIceCandidateFilter = function(filter) {
<       iceCandidateFilter = filter;
<    };
---
>     /**
>      * Sets a function to warn about the peer connection closing.
>      *  @param {Function} handler: a function that gets an easyrtcid as an argument.
>      */
>     this.setPeerClosedListener = function( handler ) {
>        this.onPeerClosed = handler;
>     };
> 
>     /**
>      * Sets a function to receive warnings about the peer connection
>      * failing. The peer connection may recover by itself.
>      *  @param {Function} failingHandler: a function that gets an easyrtcid as an argument.
>      *  @param {Function} recoveredHandler: a function that gets an easyrtcid as an argument.
>      */
>     this.setPeerFailingListener = function( failingHandler, recoveredHandler ) {
>        this.onPeerFailing = failingHandler;
>        this.onPeerRecovered = recoveredHandler;
>     };
> 
>     /**
>      * Sets a function which filters IceCandidate records being sent or received.
>      *
>      * Candidate records can be received while they are being generated locally (before being
>      * sent to a peer), and after they are received by the peer. The filter receives two arguments, the candidate record and a boolean
>      * flag that is true for a candidate being received from another peer,
>      * and false for a candidate that was generated locally. The candidate record has the form:
>      *  {type: 'candidate', label: sdpMLineIndex, id: sdpMid, candidate: candidateString}
>      * The function should return one of the following: the input candidate record, a modified candidate record, or null (indicating that the
>      * candidate should be discarded).
>      * @param {Function} filter
>      */
>     this.setIceCandidateFilter = function(filter) {
>         iceCandidateFilter = filter;
>     };
>     
>     /**
>      * Sets a function that listens on IceConnectionStateChange events.
>      *
>      * During ICE negotiation the peer connection fires the iceconnectionstatechange event. 
>      * It is sometimes useful for the application to learn about these changes, especially if the ICE connection fails.
>      * The function should accept two parameters: the easyrtc id of the peer and the iceconnectionstatechange event target.
>      * @param {Function} listener
>      */
>     this.setIceConnectionStateChangeListener = function(listener) {
>        iceConnectionStateChangeListener = listener;
>     };
310a1883
> 
330d1902
< 
331a1904
>      * @private
337,339c1910,1912
<        return (socket &&
<               ( ( socket.socket && socket.socket.connected)
<                 || socket.connected ));
---
>        return socket && (
>             (socket.socket && socket.socket.connected) || socket.connected
>         ); 
342d1914
< 
344,349c1916,1925
<     var haveAudioVideo = {audio: false, video: false};
< //
< // Maps a key to a language specific string using the easyrtc_constantStrings map.
< // Defaults to the key if the key can not be found, but outputs a warning in that case.
< // This function is only used internally by easyrtc.js
< //
---
>     //
>     // Maps a key to a language specific string using the easyrtc_constantStrings map.
>     // Defaults to the key if the key can not be found, but outputs a warning in that case.
>     // This function is only used internally by easyrtc.js
>     //
>     var haveAudioVideo = {
>         audio: false, 
>         video: false    
>     };
>     
359c1935
<             console.warn("Could not find key='" + key + "' in easyrtc_constantStrings");
---
>             self.showError(self.errCodes.DEVELOPER_ERR, "Could not find key='" + key + "' in easyrtc_constantStrings");
362a1939,1940
> 
>     /** @private */
369a1948,1949
> 
>     /** @private */
371a1952
>     //
373c1954,1956
<     /** This function checks if an attempt was made to add an event listener or
---
> 
>     /** 
>      * This function checks if an attempt was made to add an event listener or
381c1964
<             self.showError(self.errCodes.DEVELOPER_ERR, src + " called without a string as the first argument");
---
>             self.showError(self.errCodes.DEVELOPER_ERR, callingFunction + " called without a string as the first argument");
385c1968
<             self.showError(self.errCodes.DEVELOPER_ERR, src + " called with a bad event name = " + eventName);
---
>             self.showError(self.errCodes.DEVELOPER_ERR, callingFunction + " called with a bad event name = " + eventName);
413a1997
> 
433a2018
> 
450,451c2035,2038
<     /** Error codes that the EasyRTC will use in the errorCode field of error object passed
<      *  to error handler set by easyrtc.setOnError. The error codes are short printable strings.
---
> 
>     /** 
>      * Error codes that the EasyRTC will use in the errorCode field of error object passed
>      * to error handler set by easyrtc.setOnError. The error codes are short printable strings.
466c2053,2055
<         ICECANDIDATE_ERR: "ICECANDIDATE_ERROR"
---
>         ICECANDIDATE_ERR: "ICECANDIDATE_ERR",
>         NOVIABLEICE: "NOVIABLEICE",
>         SIGNAL_ERR: "SIGNAL_ERR"
468c2057,2059
<     this.apiVersion = "1.0.15";
---
> 
>     this.apiVersion = "1.0.17";
>     
470a2062
>     
472a2065
>     
474a2068
>     
476a2071
>     
478a2074
>     
480a2077,2078
>     
>     /** @private */
484a2083,2084
>     
>     /** @private */
486,491c2086,2089
<     var receivedMediaConstraints = {
<         'mandatory': {
<             'OfferToReceiveAudio': true,
<             'OfferToReceiveVideo': true
<         }
<     };
---
>     
>     /** @private */
>     var receivedMediaConstraints = {};
> 
498c2096,2102
<         receivedMediaConstraints.mandatory.OfferToReceiveAudio = value;
---
>         if (webrtcDetectedBrowser === "firefox") {
>             receivedMediaConstraints.offerToReceiveAudio = value;
>         }
>         else {
>             receivedMediaConstraints.mandatory = receivedMediaConstraints.mandatory || {};
>             receivedMediaConstraints.mandatory.OfferToReceiveAudio = value;
>         }
499a2104
> 
506c2111,2117
<         receivedMediaConstraints.mandatory.OfferToReceiveVideo = value;
---
>         if (webrtcDetectedBrowser === "firefox") {
>            receivedMediaConstraints.offerToReceiveVideo = value;
>         }
>         else {
>             receivedMediaConstraints.mandatory = receivedMediaConstraints.mandatory || {};
>             receivedMediaConstraints.mandatory.OfferToReceiveVideo = value;
>         }
508a2120,2124
>     // True by default
>     // TODO should not be true by default only for legacy
>     this.enableAudioReceive(true);
>     this.enableVideoReceive(true);
> 
510,511c2126,2127
<         if (MediaStreamTrack.getSources) {
<             MediaStreamTrack.getSources(function(sources) {
---
>         navigator.mediaDevices.enumerateDevices().then(
>              function(values) {
513,515c2129,2131
<                 for (var i = 0; i < sources.length; i++) {
<                     var source = sources[i];
<                     if (source.kind == sourceType) {
---
>                 for (var i = 0; i < values.length; i++) {
>                     var source = values[i];
>                     if (source.kind === sourceType) {
520,524c2136,2141
<             });
<         }
<         else {
<             callback([]);
<         }
---
>              }
>           ).catch(
>             function(reason) {
>                webrtcUtils.log("Unable to enumerate devices (" + reason + ")");
>             }
>         );
529,531c2146
<      * @param {Function} callback receives list of {label:String, id:String, kind:"audio"}
<      * Note: the label string always seems to be the empty string if you aren't using https.
<      * Note: not supported by Firefox.
---
>      * @param {Function} callback receives list of {deviceId:String, groupId:String, label:String, kind:"audio"}
535c2150
<      *                   console.log("label=" + list[i].label + ", id= " + list[i].id);
---
>      *                   console.log("label=" + list[i].label + ", id= " + list[i].deviceId);
540c2155
<        getSourceList(callback, "audio");
---
>        getSourceList(callback, "audioinput");
545,547c2160
<      * @param {Function} callback receives list of {facing:String, label:String, id:String, kind:"video"}
<      * Note: the label string always seems to be the empty string if you aren't using https.
<      * Note: not supported by Firefox.
---
>      * @param {Function} callback receives list of {deviceId:String, groupId:String, label:String, kind:"video"}
551c2164
<      *                   console.log("label=" + list[i].label + ", id= " + list[i].id);
---
>      *                   console.log("label=" + list[i].label + ", id= " + list[i].deviceId);
556c2169
<        getSourceList(callback, "video");
---
>        getSourceList(callback, "videoinput");
616,652d2228
<     /**
<      * This method allows you to join a single room. It may be called multiple times to be in
<      * multiple rooms simultaneously. It may be called before or after connecting to the server.
<      * Note: the successCB and failureDB will only be called if you are already connected to the server.
<      * @param {String} roomName the room to be joined.
<      * @param {String} roomParameters application specific parameters, can be null.
<      * @param {Function} successCB called once, with a roomName as it's argument, once the room is joined.
<      * @param {Function} failureCB called if the room can not be joined. The arguments of failureCB are errorCode, errorText, roomName.
<      */
<     this.joinRoom = function(roomName, roomParameters, successCB, failureCB) {
<         if (self.roomJoin[roomName]) {
<             console.error("Developer error: attempt to join room " + roomName + " which you are already in.");
<             return;
<         }
< 
<         var newRoomData = {roomName: roomName};
<         if (roomParameters) {
<             try {
<                 JSON.stringify(roomParameters);
<             } catch (error) {
<                 self.showError(self.errCodes.DEVELOPER_ERR, "non-jsonable parameter to easyrtc.joinRoom");
<                 throw "Developer error, see application error messages";
<             }
<             var parameters = {};
<             for (var key in roomParameters) {
<                 if (roomParameters.hasOwnProperty(key)) {
<                     parameters[key] = roomParameters[key];
<                 }
<             }
<             newRoomData.roomParameter = parameters;
<         }
<         var msgData = {
<             roomJoin: {}
<         };
<         var roomData;
<         var signallingSuccess, signallingFailure;
<         if (self.webSocket) {
654,655c2230,2231
<             msgData.roomJoin[roomName] = newRoomData;
<             signallingSuccess = function(msgType, msgData) {
---
>     /** @private */
>     this._desiredVideoProperties = {}; // default camera
657,717c2233,2241
<                 roomData = msgData.roomData;
<                 self.roomJoin[roomName] = newRoomData;
<                 if (successCB) {
<                     successCB(roomName);
<                 }
< 
<                 processRoomData(roomData);
<             };
<             signallingFailure = function(errorCode, errorText) {
<                 if (failureCB) {
<                     failureCB(errorCode, errorText, roomName);
<                 }
<                 else {
<                     self.showError(errorCode, self.format(self.getConstantString("unableToEnterRoom"), roomName, errorText));
<                 }
<             };
<             sendSignalling(null, "roomJoin", msgData, signallingSuccess, signallingFailure);
<         }
<         else {
<             self.roomJoin[roomName] = newRoomData;
<         }
< 
<     };
<     /**
<      * This function allows you to leave a single room. Note: the successCB and failureDB
<      *  arguments are optional and will only be called if you are already connected to the server.
<      * @param {String} roomName
<      * @param {Function} successCallback - A function which expects a roomName.
<      * @param {Function} failureCallback - A function which expects the following arguments: errorCode, errorText, roomName.
<      * @example
<      *    easyrtc.leaveRoom("freds_room");
<      *    easyrtc.leaveRoom("freds_room", function(roomName){ console.log("left the room")},
<      *                       function(errorCode, errorText, roomName){ console.log("left the room")});
<      */
<     this.leaveRoom = function(roomName, successCallback, failureCallback) {
<         var roomItem;
<         if (self.roomJoin[roomName]) {
<             if (!self.webSocket) {
<                 delete self.roomJoin[roomName];
<             }
<             else {
<                 roomItem = {};
<                 roomItem[roomName] = {roomName: roomName};
<                 sendSignalling(null, "roomLeave", {roomLeave: roomItem},
<                 function(msgType, msgData) {
<                     var roomData = msgData.roomData;
<                     processRoomData(roomData);
<                     if (successCallback) {
<                         successCallback(roomName);
<                     }
<                 },
<                         function(errorCode, errorText) {
<                             if (failureCallback) {
<                                 failureCallback(errorCode, errorText, roomName);
<                             }
<                         });
<             }
<         }
<     };
<     /** @private */
<     this._desiredVideoProperties = {}; // default camera
---
>     /**
>      * Specify particular video source. Call this before you call easyrtc.initMediaSource().
>      * @param {String} videoSrcId is a id value from one of the entries fetched by getVideoSourceList. null for default.
>      * @example easyrtc.setVideoSource( videoSrcId);
>      */
>     this.setVideoSource = function(videoSrcId) {
>         self._desiredVideoProperties.videoSrcId = videoSrcId;
>         delete self._desiredVideoProperties.screenCapture;
>     };
718a2243,2244
>     /** @private */
>     this._desiredAudioProperties = {}; // default camera
722,724c2248,2249
<      * Note: this function isn't supported by Firefox.
<      * @param {String} videoSrcId is a id value from one of the entries fetched by getVideoSourceList. null for default.
<      * @example easyrtc.setVideoSrc( videoSrcId);
---
>      * @param {String} audioSrcId is a id value from one of the entries fetched by getAudioSourceList. null for default.
>      * @example easyrtc.setAudioSource( audioSrcId);
726,728c2251,2252
<     this.setVideoSource = function(videoSrcId) {
<         self._desiredVideoProperties.videoSrcId = videoSrcId;
<         delete self._desiredVideoProperties.screenCapture;
---
>     this.setAudioSource = function(audioSrcId) {
>         self._desiredAudioProperties.audioSrcId = audioSrcId;
730,734c2254
<     /**
<      * Temporary alias for easyrtc.setVideoSource
<      */
<     this.setVideoSrc = this.setVideoSource;
<     delete this._desiredVideoProperties.screenCapture;
---
> 
737c2257
<      *  assuming it is supported. If you don't pass any parameters, it will default to 720p dimensions.
---
>      *  assuming it is supported. If you don't pass any parameters, it will use default camera dimensions.
747,750d2266
<         if (!width) {
<             width = 1280;
<             height = 720;
<         }
805,812c2321,2334
<             constraints.video = {mandatory: {}, optional: []};
<             if (self._desiredVideoProperties.width) {
<                 constraints.video.mandatory.maxWidth = self._desiredVideoProperties.width;
<                 constraints.video.mandatory.minWidth = self._desiredVideoProperties.width;
<             }
<             if (self._desiredVideoProperties.width) {
<                 constraints.video.mandatory.maxHeight = self._desiredVideoProperties.height;
<                 constraints.video.mandatory.minHeight = self._desiredVideoProperties.height;
---
>             if (webrtcDetectedBrowser === "firefox") {
>                 constraints.video = {}; 
>                 if (self._desiredVideoProperties.width) {
>                     constraints.video.width = self._desiredVideoProperties.width;
>                 }
>                 if (self._desiredVideoProperties.height) {
>                     constraints.video.height = self._desiredVideoProperties.height;
>                 }
>                 if (self._desiredVideoProperties.frameRate) {
>                     constraints.video.frameRate = { max: self._desiredVideoProperties.frameRate};
>                 }
>                 if (self._desiredVideoProperties.videoSrcId) {
>                     constraints.video.deviceId = self._desiredVideoProperties.videoSrcId;
>                 }
814,815c2336,2356
<             if (self._desiredVideoProperties.frameRate) {
<                 constraints.video.mandatory.maxFrameRate = self._desiredVideoProperties.frameRate;
---
>             else { // chrome and opera
>                 constraints.video = {mandatory: {}, optional: []};
>                 if (self._desiredVideoProperties.width) {
>                     constraints.video.mandatory.maxWidth = self._desiredVideoProperties.width;
>                     constraints.video.mandatory.minWidth = self._desiredVideoProperties.width;
>                 }
>                 if (self._desiredVideoProperties.height) {
>                     constraints.video.mandatory.maxHeight = self._desiredVideoProperties.height;
>                     constraints.video.mandatory.minHeight = self._desiredVideoProperties.height;
>                 }
>                 if (self._desiredVideoProperties.frameRate) {
>                     constraints.video.mandatory.maxFrameRate = self._desiredVideoProperties.frameRate;
>                 }
>                 if (self._desiredVideoProperties.videoSrcId) {
>                     constraints.video.optional = constraints.video.optional || [];
>                     constraints.video.optional.push({sourceId: self._desiredVideoProperties.videoSrcId});
>                 }
>                 // hack for opera
>                 if (constraints.video.mandatory.length === 0 && constraints.video.optional.length === 0) {
>                     constraints.video = true;
>                 }
817,818c2358,2368
<             if (self._desiredVideoProperties.videoSrcId) {
<                 constraints.video.optional.push({sourceId: self._desiredVideoProperties.videoSrcId});
---
>         }
> 
>         if (!self.audioEnabled) {
>             constraints.audio = false;
>         }
>         else {
>             if (webrtcDetectedBrowser === "firefox") {
>                 constraints.audio = {}; 
>                 if (self._desiredAudioProperties.audioSrcId) {
>                     constraints.audio.deviceId = self._desiredAudioProperties.audioSrcId;
>                 }
820,822c2370,2375
<             // hack for opera
<             if (constraints.video.mandatory.length === 0 && constraints.video.optional.length === 0) {
<                 constraints.video = true;
---
>             else { // chrome and opera
>                 constraints.audio = {mandatory: {}, optional: []};
>                 if (self._desiredAudioProperties.audioSrcId) {
>                     constraints.audio.optional = constraints.audio.optional || [];
>                     constraints.audio.optional.push({sourceId: self._desiredAudioProperties.audioSrcId});
>                 }
825d2377
<         constraints.audio = self.audioEnabled;
858c2410
<                 console.log("debug " + (new Date()).toISOString() + " : " + message + " [" + srcLine + "]");
---
>                 webrtcUtils.log("debug " + (new Date()).toISOString() + " : " + message + " [" + srcLine + "]");
865,871c2417
< //
< // this is a temporary version used until we connect to the server.
< //
<     this.updatePresence = function(state, statusText) {
<         self.presenceShow = state;
<         self.presenceStatus = statusText;
<     };
---
> 
890,894d2435
<         try {
<             self.createRTCPeerConnection({"iceServers": []}, null);
<         } catch (oops) {
<             return false;
<         }
934c2475
<     var serverPath = null;
---
>     var serverPath = null; // this was null, but that was generating an error.
948,970c2489,2490
<     var updateConfigurationInfo = function() {
< 
<     }; // dummy placeholder for when we aren't connected
< //
< //
< //  peerConns is a map from caller names to the below object structure
< //     {  startedAV: boolean,  -- true if we have traded audio/video streams
< //        dataChannelS: RTPDataChannel for outgoing messages if present
< //        dataChannelR: RTPDataChannel for incoming messages if present
< //        dataChannelReady: true if the data channel can be used for sending yet
< //        connectTime: timestamp when the connection was started
< //        sharingAudio: true if audio is being shared
< //        sharingVideo: true if video is being shared
< //        cancelled: temporarily true if a connection was cancelled by the peer asking to initiate it
< //        candidatesToSend: SDP candidates temporarily queued
< //        streamsAddedAcks: ack callbacks waiting for stream received messages
< //        pc: RTCPeerConnection
< //        mediaStream: mediaStream
< //     function callSuccessCB(string) - see the easyrtc.call documentation.
< //        function callFailureCB(errorCode, string) - see the easyrtc.call documentation.
< //        function wasAcceptedCB(boolean,string) - see the easyrtc.call documentation.
< //     }
< //
---
>     // dummy placeholder for when we aren't connected
>     var updateConfigurationInfo = function() { }; 
971a2492,2511
>     //
>     //
>     //  peerConns is a map from caller names to the below object structure
>     //     {  startedAV: boolean,  -- true if we have traded audio/video streams
>     //        dataChannelS: RTPDataChannel for outgoing messages if present
>     //        dataChannelR: RTPDataChannel for incoming messages if present
>     //        dataChannelReady: true if the data channel can be used for sending yet
>     //        connectTime: timestamp when the connection was started
>     //        sharingAudio: true if audio is being shared
>     //        sharingVideo: true if video is being shared
>     //        cancelled: temporarily true if a connection was cancelled by the peer asking to initiate it
>     //        candidatesToSend: SDP candidates temporarily queued
>     //        streamsAddedAcks: ack callbacks waiting for stream received messages
>     //        pc: RTCPeerConnection
>     //        mediaStream: mediaStream
>     //     function callSuccessCB(string) - see the easyrtc.call documentation.
>     //        function callFailureCB(errorCode, string) - see the easyrtc.call documentation.
>     //        function wasAcceptedCB(boolean,string) - see the easyrtc.call documentation.
>     //     }
>     //
973,976d2512
< //
< // a map keeping track of whom we've requested a call with so we don't try to
< // call them a second time before they've responded.
< //
977a2514,2517
>     //
>     // a map keeping track of whom we've requested a call with so we don't try to
>     // call them a second time before they've responded.
>     //
979,985c2519
<     /**
<      * Disconnect from the EasyRTC server.
<      * @example
<      *    easyrtc.disconnect();
<      */
<     this.disconnect = function() {
<     };
---
>     
992a2527
> 
998a2534
> 
1003a2540
>     
1008a2546
> 
1010c2548
<      * This function gets the statistics for a particular peer connection.
---
>      * This function gets the raw RTCPeerConnection for a given easyrtcid
1012,1015c2550,2551
<      * @param {Function} callback gets the easyrtcid for the peer and a map of {userDefinedKey: value}. If there is no peer connection to easyrtcid, then the map will
<      *  have a value of {connected:false}.
<      * @param {Object} filter depends on whether Chrome or Firefox is used. See the default filters for guidance.
<      * It is still experimental.
---
>      * @param {RTCPeerConnection} for that easyrtcid, or null if no connection exists
>      * Submitted by Fabian Bernhard.
1017,1022c2553,2596
<     this.getPeerStatistics = function(easyrtcid, callback, filter) {
<         if (isFirefox) {
<             self.getFirefoxPeerStatistics(easyrtcid, callback, filter);
<         }
<         else {
<             self.getChromePeerStatistics(easyrtcid, callback, filter);
---
>     this.getPeerConnectionByUserId = function(userId) {
>     	if (peerConns && peerConns[userId]) {
>     		return peerConns[userId].pc;
>     	}
>     	return null;
>     };
> 
> 
>     var chromeStatsFilter = [
>         {
>             "googTransmitBitrate": "transmitBitRate",
>             "googActualEncBitrate": "encodeRate",
>             "googAvailableSendBandwidth": "availableSendRate"
>         },
>         {
>             "googCodecName": "audioCodec",
>             "googTypingNoiseState": "typingNoise",
>             "packetsSent": "audioPacketsSent",
>             "bytesSent": "audioBytesSent"
>         },
>         {
>             "googCodecName": "videoCodec",
>             "googFrameRateSent": "outFrameRate",
>             "packetsSent": "videoPacketsSent",
>             "bytesSent": "videoBytesSent"
>         },
>         {
>             "packetsLost": "videoPacketsLost",
>             "packetsReceived": "videoPacketsReceived",
>             "bytesReceived": "videoBytesReceived",
>             "googFrameRateOutput": "frameRateOut"
>         },
>         {
>             "packetsLost": "audioPacketsLost",
>             "packetsReceived": "audioPacketsReceived",
>             "bytesReceived": "audioBytesReceived",
>             "audioOutputLevel": "audioOutputLevel"
>         },
>         {
>             "googRemoteAddress": "remoteAddress",
>             "googActiveConnection": "activeConnection"
>         },
>         {
>             "audioInputLevel": "audioInputLevel"
1023a2598,2611
>     ];
> 
>     var firefoxStatsFilter = {
>         "outboundrtp_audio.bytesSent": "audioBytesSent",
>         "outboundrtp_video.bytesSent": "videoBytesSent",
>         "inboundrtp_video.bytesReceived": "videoBytesReceived",
>         "inboundrtp_audio.bytesReceived": "audioBytesReceived",
>         "outboundrtp_audio.packetsSent": "audioPacketsSent",
>         "outboundrtp_video.packetsSent": "videoPacketsSent",
>         "inboundrtp_video.packetsReceived": "videoPacketsReceived",
>         "inboundrtp_audio.packetsReceived": "audioPacketsReceived",
>         "inboundrtp_video.packetsLost": "videoPacketsLost",
>         "inboundrtp_audio.packetsLost": "audioPacketsLost",
>         "firefoxRemoteAddress": "remoteAddress"
1026c2614,2616
<     this.getFirefoxPeerStatistics = function(peerId, callback, filter) {
---
>     var standardStatsFilter = webrtcDetectedBrowser === "firefox" ? firefoxStatsFilter : chromeStatsFilter;
> 
>     function getFirefoxPeerStatistics(peerId, callback, filter) {
1091c2681
<                         console.log("unable to get statistics");
---
>                         webrtcUtils.log("unable to get statistics");
1097c2687
<     };
---
>     }
1099c2689
<     this.getChromePeerStatistics = function(peerId, callback, filter) {
---
>     function getChromePeerStatistics(peerId, callback, filter) {
1237,1314c2827
<     };
<     this.chromeStatsFilter = [
<         {
<             "googTransmitBitrate": "transmitBitRate",
<             "googActualEncBitrate": "encodeRate",
<             "googAvailableSendBandwidth": "availableSendRate"
<         },
<         {
<             "googCodecName": "audioCodec",
<             "googTypingNoiseState": "typingNoise",
<             "packetsSent": "audioPacketsSent",
<             "bytesSent": "audioBytesSent"
<         },
<         {
<             "googCodecName": "videoCodec",
<             "googFrameRateSent": "outFrameRate",
<             "packetsSent": "videoPacketsSent",
<             "bytesSent": "videoBytesSent"
<         },
<         {
<             "packetsLost": "videoPacketsLost",
<             "packetsReceived": "videoPacketsReceived",
<             "bytesReceived": "videoBytesReceived",
<             "googFrameRateOutput": "frameRateOut"
<         },
<         {
<             "packetsLost": "audioPacketsLost",
<             "packetsReceived": "audioPacketsReceived",
<             "bytesReceived": "audioBytesReceived",
<             "audioOutputLevel": "audioOutputLevel"
<         },
<         {
<             "googRemoteAddress": "remoteAddress",
<             "googActiveConnection": "activeConnection"
<         },
<         {
<             "audioInputLevel": "audioInputLevel"
<         }
<     ];
<     this.firefoxStatsFilter = {
<         "outboundrtp_audio.bytesSent": "audioBytesSent",
<         "outboundrtp_video.bytesSent": "videoBytesSent",
<         "inboundrtp_video.bytesReceived": "videoBytesReceived",
<         "inboundrtp_audio.bytesReceived": "audioBytesReceived",
<         "outboundrtp_audio.packetsSent": "audioPacketsSent",
<         "outboundrtp_video.packetsSent": "videoPacketsSent",
<         "inboundrtp_video.packetsReceived": "videoPacketsReceived",
<         "inboundrtp_audio.packetsReceived": "audioPacketsReceived",
<         "inboundrtp_video.packetsLost": "videoPacketsLost",
<         "inboundrtp_audio.packetsLost": "audioPacketsLost",
<         "firefoxRemoteAddress": "remoteAddress"
<     };
<     this.standardStatsFilter = isFirefox ? self.firefoxStatsFilter : self.chromeStatsFilter;
<     /** Provide a set of application defined fields that will be part of this instances
<      * configuration information. This data will get sent to other peers via the websocket
<      * path.
<      * @param {String} roomName - the room the field is attached to.
<      * @param {String} fieldName - the name of the field.
<      * @param {Object} fieldValue - the value of the field.
<      * @example
<      *   easyrtc.setRoomApiField("trekkieRoom",  "favorite_alien", "Mr Spock");
<      *   easyrtc.setRoomOccupantListener( function(roomName, list){
<      *      for( var i in list ){
<      *         console.log("easyrtcid=" + i + " favorite alien is " + list[i].apiFields.favorite_alien);
<      *      }
<      *   });
<      */
<     this.setRoomApiField = function(roomName, fieldName, fieldValue) {
<         //
<         // if we're not connected yet, we'll just cache the fields until we are.
<         //
<         if (!self._roomApiFields) {
<             self._roomApiFields = {};
<         }
<         if (!fieldName && !fieldValue) {
<             delete self._roomApiFields[roomName];
<             return;
<         }
---
>     }
1316,1329c2829,2839
<         if (!self._roomApiFields[roomName]) {
<             self._roomApiFields[roomName] = {};
<         }
<         if (fieldValue !== undefined && fieldValue !== null) {
<             if (typeof fieldValue === "object") {
<                 try {
<                     JSON.stringify(fieldValue);
<                 }
<                 catch (jsonError) {
<                     self.showError(self.errCodes.DEVELOPER_ERR, "easyrtc.setRoomApiField passed bad object ");
<                     return;
<                 }
<             }
<             self._roomApiFields[roomName][fieldName] = {fieldName: fieldName, fieldValue: fieldValue};
---
>     /**
>      * This function gets the statistics for a particular peer connection.
>      * @param {String} easyrtcid
>      * @param {Function} callback gets the easyrtcid for the peer and a map of {userDefinedKey: value}. If there is no peer connection to easyrtcid, then the map will
>      *  have a value of {connected:false}.
>      * @param {Object} filter depends on whether Chrome or Firefox is used. See the default filters for guidance.
>      * It is still experimental.
>      */
>     this.getPeerStatistics = function(easyrtcid, callback, filter) {
>         if (webrtcDetectedBrowser === "firefox") {
>             self.getFirefoxPeerStatistics(easyrtcid, callback, filter);
1332,1335c2842
<             delete self._roomApiFields[roomName][fieldName];
<         }
<         if (self.webSocketConnected) {
<             _enqueueSendRoomApi(roomName);
---
>             self.getChromePeerStatistics(easyrtcid, callback, filter);
1338,1354c2845
<     var roomApiFieldTimer = null;
<     /** @private
<      * @param {String} roomName
<      */
<     function _enqueueSendRoomApi(roomName) {
< //
< // Rather than issue the send request immediately, we set a timer so we can accumulate other
< // calls
< //
<         if (roomApiFieldTimer) {
<             clearTimeout(roomApiFieldTimer);
<         }
<         roomApiFieldTimer = setTimeout(function() {
<             _sendRoomApiFields(roomName, self._roomApiFields[roomName]);
<             roomApiFieldTimer = null;
<         }, 10);
<     }
---
> 
1356,1357c2847,2848
<      *  @private
<      *  @param roomName
---
>      * @private
>      * @param roomName
1360c2851
<     function _sendRoomApiFields(roomName, fields) {
---
>     function sendRoomApiFields(roomName, fields) {
1380,1388c2871,2951
<     /** Default error reporting function. The default implementation displays error messages
<      *  in a programmatically created div with the id easyrtcErrorDialog. The div has title
<      *  component with a class name of easyrtcErrorDialog_title. The error messages get added to a
<      *  container with the id easyrtcErrorDialog_body. Each error message is a text node inside a div
<      *  with a class of easyrtcErrorDialog_element. There is an "okay" button with the className of easyrtcErrorDialog_okayButton.
<      *  @param {String} messageCode An error message code
<      *  @param {String} message the error message text without any markup.
<      *  @example
<      *      easyrtc.showError("BAD_NAME", "Invalid username");
---
> 
>     /** @private */
>     var roomApiFieldTimer = null;
> 
>     /** 
>      * @private
>      * @param {String} roomName
>      */
>     function enqueueSendRoomApi(roomName) {
>         //
>         // Rather than issue the send request immediately, we set a timer so we can accumulate other
>         // calls
>         //
>         if (roomApiFieldTimer) {
>             clearTimeout(roomApiFieldTimer);
>         }
>         roomApiFieldTimer = setTimeout(function() {
>             sendRoomApiFields(roomName, self._roomApiFields[roomName]);
>             roomApiFieldTimer = null;
>         }, 10);
>     }
> 
>     /** Provide a set of application defined fields that will be part of this instances
>      * configuration information. This data will get sent to other peers via the websocket
>      * path.
>      * @param {String} roomName - the room the field is attached to.
>      * @param {String} fieldName - the name of the field.
>      * @param {Object} fieldValue - the value of the field.
>      * @example
>      *   easyrtc.setRoomApiField("trekkieRoom",  "favorite_alien", "Mr Spock");
>      *   easyrtc.setRoomOccupantListener( function(roomName, list){
>      *      for( var i in list ){
>      *         console.log("easyrtcid=" + i + " favorite alien is " + list[i].apiFields.favorite_alien);
>      *      }
>      *   });
>      */
>     this.setRoomApiField = function(roomName, fieldName, fieldValue) {
>         //
>         // if we're not connected yet, we'll just cache the fields until we are.
>         //
>         if (!self._roomApiFields) {
>             self._roomApiFields = {};
>         }
>         if (!fieldName && !fieldValue) {
>             delete self._roomApiFields[roomName];
>             return;
>         }
> 
>         if (!self._roomApiFields[roomName]) {
>             self._roomApiFields[roomName] = {};
>         }
>         if (fieldValue !== undefined && fieldValue !== null) {
>             if (typeof fieldValue === "object") {
>                 try {
>                     JSON.stringify(fieldValue);
>                 }
>                 catch (jsonError) {
>                     self.showError(self.errCodes.DEVELOPER_ERR, "easyrtc.setRoomApiField passed bad object ");
>                     return;
>                 }
>             }
>             self._roomApiFields[roomName][fieldName] = {fieldName: fieldName, fieldValue: fieldValue};
>         }
>         else {
>             delete self._roomApiFields[roomName][fieldName];
>         }
>         if (self.webSocketConnected) {
>             enqueueSendRoomApi(roomName);
>         }
>     };
> 
>     /** 
>      * Default error reporting function. The default implementation displays error messages
>      * in a programmatically created div with the id easyrtcErrorDialog. The div has title
>      * component with a class name of easyrtcErrorDialog_title. The error messages get added to a
>      * container with the id easyrtcErrorDialog_body. Each error message is a text node inside a div
>      * with a class of easyrtcErrorDialog_element. There is an "okay" button with the className of easyrtcErrorDialog_okayButton.
>      * @param {String} messageCode An error message code
>      * @param {String} message the error message text without any markup.
>      * @example
>      *     easyrtc.showError("BAD_NAME", "Invalid username");
1393c2956,2958
<     /** @private
---
> 
>     /** 
>      * @private
1430,1435c2995
< //
< // easyrtc.createObjectURL builds a URL from a media stream.
< // Arguments:
< //     mediaStream - a media stream object.
< // The video object in Chrome expects a URL.
< //
---
> 
1437a2998,3003
>     //
>     // easyrtc.createObjectURL builds a URL from a media stream.
>     // Arguments:
>     //     mediaStream - a media stream object.
>     // The video object in Chrome expects a URL.
>     //
1453a3020
> 
1459c3026
<      *     console.log( easyrtc.cleanId('&hello'));
---
>      *   console.log( easyrtc.cleanId('&hello'));
1471,1472c3038,3040
<     /** Set a callback that will be invoked when the application enters or leaves a room.
<      *
---
> 
>     /** 
>      * Set a callback that will be invoked when the application enters or leaves a room.
1487c3055,3057
<     /** Set the callback that will be invoked when the list of people logged in changes.
---
> 
>     /** 
>      * Set the callback that will be invoked when the list of people logged in changes.
1489c3059
<      *  a map whose ideas are easyrtcids and whose values are in turn maps
---
>      * a map whose ideas are easyrtcids and whose values are in turn maps
1491,1492c3061,3062
<      *  username, applicationName, browserFamily, browserMajor, osFamily, osMajor, deviceFamily.
<      *  The third argument is the listener is the innerMap for the connections own data (not needed by most applications).
---
>      * username, applicationName, browserFamily, browserMajor, osFamily, osMajor, deviceFamily.
>      * The third argument is the listener is the innerMap for the connections own data (not needed by most applications).
1503a3074
>     
1515a3087
>     
1526a3099
> 
1561a3135
> 
1570a3145
> 
1580a3156
> 
1596c3172
< 
---
>     /** @private */
1619a3196
>     /** @private */
1624c3201,3203
<             mediaMap[streamName] = namedLocalMediaStreams[streamName].id || "default";
---
>             if (namedLocalMediaStreams.hasOwnProperty(streamName)) {    
>                 mediaMap[streamName] = namedLocalMediaStreams[streamName].id || "default";
>             }
1629c3208
< 
---
>     /** @private */
1638,1640c3217,3222
<             var mediaIds = buildMediaIds();
<             for (roomName in self.roomData) {
<                 self.setRoomApiField(roomName, "mediaIds", mediaIds);
---
>             var mediaIds = buildMediaIds(),
>                 roomData = self.roomData;
>             for (roomName in roomData) {
>                 if (roomData.hasOwnProperty(roomName)) {
>                     self.setRoomApiField(roomName, "mediaIds", mediaIds);
>                 }
1646,1649c3228,3231
<       * Allow an externally created mediastream (ie, created by another
<       * library) to be used within easyrtc. Tracking when it closes
<       * must be done by the supplying party.
<       */
---
>      * Allow an externally created mediastream (ie, created by another
>      * library) to be used within easyrtc. Tracking when it closes
>      * must be done by the supplying party.
>      */
1652a3235,3236
> 
>     /** @private */
1671,1678c3255,3285
<             mediaIds = self.getRoomApiField(roomName, easyrtcId, "mediaIds");
<             if (!mediaIds) {
<                 continue;
<             }
<             for (streamName in mediaIds) {
<                 if (mediaIds.hasOwnProperty(streamName) &&
<                         mediaIds[streamName] === webrtcStreamId) {
<                     return streamName;
---
>             if (self.roomData.hasOwnProperty(roomName)) {
>                 mediaIds = self.getRoomApiField(roomName, easyrtcId, "mediaIds");
>                 if (!mediaIds) {
>                     continue;
>                 }
>                 for (streamName in mediaIds) {
>                     if (mediaIds.hasOwnProperty(streamName) &&
>                             mediaIds[streamName] === webrtcStreamId) {
>                         return streamName;
>                     }
>                 }
>                 //
>                 // a stream from chrome to firefox will be missing it's id/label.
>                 // there is no correct solution. 
>                 //
>                 if (webrtcDetectedBrowser === "firefox") {
> 
>                    // if there is a stream called default, return it in preference
>                    if (mediaIds["default"]) {
>                        return "default"; 
>                    }
> 
>                    //
>                    // otherwise return the first name we find. If there is more than
>                    // one, complain to Mozilla.
>                    //
>                    for(var anyName in mediaIds) {
>                         if (mediaIds.hasOwnProperty(anyName)) {
>                             return anyName;
>                         }
>                    }
1680,1696d3286
<             }
<             //
<             // a stream from chrome to firefox will be missing it's id/label.
<             // there is no correct solution.
<             //
<             if( isFirefox ) {
<                // if there is a stream called default, return it in preference
<                if( mediaIds["default"] ) {
<                    return "default";
<                }
<                //
<                // otherwise return the first name we find. If there is more than
<                // one, complain to Mozilla.
<                //
<                for( var anyName in mediaIds ) {
<                    return anyName;
<                }
1698a3289
> 
1703c3294
<         if(typeof webrtcStream == "string") {
---
>         if(typeof webrtcStream === "string") {
1710a3302
>     /** @private */
1724d3315
< 
1734,1739c3325,3326
<             try {
<                 stopStream(namedLocalMediaStreams[streamName]);
<             } catch (err) {
<                 // not worth reporting an error at this location
<                 // since we didn't want the media stream anyhow.
<             }
---
>             
>             stopStream(namedLocalMediaStreams[streamName]);    
1740a3328
> 
1744c3332,3334
<                     self.setRoomApiField(roomName, "mediaIds", mediaIds);
---
>                     if (self.roomData.hasOwnProperty(roomName)) {
>                         self.setRoomApiField(roomName, "mediaIds", mediaIds);   
>                     }
1748a3339
> 
1761a3353
> 
1774a3367
> 
1787a3381
> 
1793c3387
<     self.muteVideoObject = function(videoObjectName, mute) {
---
>     this.muteVideoObject = function(videoObjectName, mute) {
1808a3403
> 
1824a3420
> 
1836a3433
> 
1845,1849c3442
<         if (typeof element.srcObject !== 'undefined') {
<             element.srcObject = null;
<         } else if (typeof element.mozSrcObject !== 'undefined') {
<             element.mozSrcObject = null;
<         } else if (typeof element.src !== 'undefined') {
---
>         if (typeof element.src !== 'undefined') {
1852c3445,3449
<         }
---
>         } else if (typeof element.srcObject !== 'undefined') {
>             element.srcObject = "";
>         } else if (typeof element.mozSrcObject !== 'undefined') {
>             element.mozSrcObject = null;
>         } 
1853a3451
> 
1880d3477
< 
1895c3492
<             easyrtc.showError(this.errCodes.DEVELOPER_ERR,
---
>             self.showError(self.errCodes.DEVELOPER_ERR, 
1904c3501,3503
<               if(streamToClone) break;
---
>               if(streamToClone) {
>                 break;
>               }
1909,1911c3508,3512
<                 var remoteStreams = peerConns[key].pc.getRemoteStreams();
<                 if( remoteStreams && remoteStreams.length > 1 ) {
<                     streamToClone = remoteStreams[0];
---
>                 if (peerConns.hasOwnProperty(key)) {
>                     var remoteStreams = peerConns[key].pc.getRemoteStreams();
>                     if( remoteStreams && remoteStreams.length > 0 ) {
>                         streamToClone = remoteStreams[0];
>                     }   
1983,1984c3584,3588
<     /** @private
<      * @param {String} x */
---
> 
>     /**
>      * @private
>      * @param {String} x 
>      */
2017,2019c3621,3624
<     /** Initializes your access to a local camera and microphone.
<      *  Failure could be caused a browser that didn't support WebRTC, or by the user
<      * not granting permission.
---
> 
>     /** 
>      * Initializes your access to a local camera and microphone.
>      * Failure could be caused a browser that didn't support WebRTC, or by the user not granting permission.
2024c3629,3630
<      * @param {String} streamName - an optional name for the media source so you can use multiple cameras and screen share simultaneously.
---
>      * @param {String} streamName - an optional name for the media source so you can use multiple cameras and 
>      * screen share simultaneously.
2033d3638
<      *
2048a3654
> 
2064d3669
< 
2071d3675
< 
2104c3708
<                         self.setVideoObjectSrc(videoObj, "");
---
>                         self.setVideoObjectSrc(videoObj, null); 
2134c3738,3740
<         /** @private
---
> 
>         /** 
>          * @private
2138c3744
<             console.log("getusermedia failed");
---
>             webrtcUtils.log("getusermedia failed");
2153c3759
<                 console.log("invoking error callback", errText);
---
>                 webrtcUtils.log("invoking error callback", errText);
2162a3769
> 
2176c3783
<                 console.log("Trying getUserMedia a second time");
---
>                 webrtcUtils.log("Trying getUserMedia a second time");
2185,2205c3792,3806
< 
<         if (self.videoEnabled || self.audioEnabled) {
<             //
<             // getUserMedia sometimes fails the first time I call it. I suspect it's a page loading
<             // issue. So I'm going to try adding a 3 second delay to allow things to settle down first.
<             // In addition, I'm going to try again after 3 seconds.
<             //
< 
< 
<             setTimeout(function() {
<                 try {
<                     firstCallTime = getCurrentTime();
<                     getUserMedia(mode, onUserMediaSuccess, tryAgain);
<                 } catch (e) {
<                     tryAgain(e);
<                 }
<             }, 1000);
<         }
<         else {
<             onUserMediaSuccess(null);
<         }
---
>          
>         //
>         // getUserMedia sometimes fails the first time I call it. I suspect it's a page loading
>         // issue. So I'm going to try adding a 1 second delay to allow things to settle down first.
>         // In addition, I'm going to try again after 3 seconds.
>         //
>         // TODO debounce timer via clearTimeout ?
>         setTimeout(function() {
>             try {
>                 firstCallTime = getCurrentTime();
>                 getUserMedia(mode, onUserMediaSuccess, tryAgain);
>             } catch (e) {
>                 tryAgain(e);
>             }
>         }, 1000);
2206a3808
> 
2230a3833
> 
2243a3847
> 
2253a3858
> 
2272a3878
> 
2286,2296c3892
<     /** @deprecated No longer supported by Google.
<      * Sets the bandwidth for sending video data.
<      * Setting the rate too low will cause connection attempts to fail. 40 is probably good lower limit.
<      * The default is 50. A value of zero will remove bandwidth limits.
<      * @param {Number} kbitsPerSecond is rate in kilobits per second.
<      * @example
<      *    easyrtc.setVideoBandwidth( 40);
<      */
<     this.setVideoBandwidth = function(kbitsPerSecond) {
<         self.showError("easyrtc.setVideoBandwidth is deprecated, it no longer has an effect.");
<     };
---
>     
2308a3905
> 
2362c3959
<             console.log("received peer message without msgType", msg);
---
>             webrtcUtils.log("received peer message without msgType", msg);
2380a3978
> 
2391a3990
> 
2413a4013
> 
2426c4026
<             easyrtc.showError(easyrtc.errCodes.DEVELOPER_ERR, "easyrtc.setUsername called after authentication");
---
>             self.showError(self.errCodes.DEVELOPER_ERR, "easyrtc.setUsername called after authentication");
2437a4038
> 
2467a4069
> 
2485a4088
> 
2500a4104
> 
2511a4116
> 
2534a4140
> 
2537a4144
>     /** @private */
2538a4146
>     /** @private */
2539a4148
>     /** @private */
2540a4150
> 
2547a4158
>     
2555a4167
>     
2576c4188
<             easyrtc.showError(easyrtc.errCodes.DEVELOPER_ERR, "Bad ice configuration passed to easyrtc.setIceUsedInCalls");
---
>             self.showError(self.errCodes.DEVELOPER_ERR, "Bad ice configuration passed to easyrtc.setIceUsedInCalls");
2581a4194,4195
>     
>     /** @private */
2583c4197,4199
<     /** @private
---
>     
>     /** 
>      * @private
2596c4212
<                 console.error("Developer error: haveTracks called about a peer you don't have a connection to");
---
>                 self.showError(self.errCodes.DEVELOPER_ERR, "haveTracks called about a peer you don't have a connection to");
2606a4223
>         
2612a4230
>         
2613a4232
>             // TODO why do we return true here ?
2616c4235,4236
<         if (!tracks)
---
>         
>         if (!tracks) {
2617a4238,4239
>         }
> 
2619a4242
> 
2627a4251
>     
2635a4260
>     
2644,2646c4269
<         if (!fields || !fields[fieldName])
<             return undefined;
<         return fields[fieldName].fieldValue;
---
>         return (!fields || !fields[fieldName]) ? undefined : fields[fieldName].fieldValue;
2648,2650c4271,4275
< //
< // Experimental function to determine if statistics gathering is supported.
< //
---
> 
>     /** @private */
>     //
>     // Experimental function to determine if statistics gathering is supported.
>     //
2661,2681d4285
<     /**
<      * Connects to the EasyRTC signaling server. You must connect before trying to
<      * call other users.
<      * @param {String} applicationName is a string that identifies the application so that different applications can have different
<      *        lists of users. Note that the server configuration specifies a regular expression that is used to check application names
<      *        for validity. The default pattern is that of an identifier, spaces are not allowed.
<      * @param {Function} successCallback (easyrtcId, roomOwner) - is called on successful connect. easyrtcId is the
<      *   unique name that the client is known to the server by. A client usually only needs it's own easyrtcId for debugging purposes.
<      *       roomOwner is true if the user is the owner of a room. It's value is random if the user is in multiple rooms.
<      * @param {Function} errorCallback (errorCode, errorText) - is called on unsuccessful connect. if null, an alert is called instead.
<      *  The errorCode takes it's value from easyrtc.errCodes.
<      * @example
<      *   easyrtc.connect("my_chat_app",
<      *                   function(easyrtcid, roomOwner){
<      *                       if( roomOwner){ console.log("I'm the room owner"); }
<      *                       console.log("my id is " + easyrtcid);
<      *                   },
<      *                   function(errorText){
<      *                       console.log("failed to connect ", erFrText);
<      *                   });
<      */
2682a4287
>     /** @private */
2684,2695d4288
<     function isEmptyObj(obj) {
<         if (obj === null || obj === undefined) {
<             return true;
<         }
<         var key;
<         for (key in obj) {
<             if (obj.hasOwnProperty(key)) {
<                 return false;
<             }
<         }
<         return true;
<     }
2696a4290,4294
>     /** @private */
>     var preallocatedSocketIo = null;
>     
>     //
>     // easyrtc.disconnect performs a clean disconnection of the client from the server.
2698,2699d4295
< // easyrtc.disconnect performs a clean disconnection of the client from the server.
< //
2729a4326,4331
> 
>     /**
>      * Disconnect from the EasyRTC server.
>      * @example
>      *    easyrtc.disconnect();
>      */
2764a4367,4368
> 
>     /** @private */
2813a4418,4419
>     /** @private */
>     //
2816a4423
>     //
2817a4425
>     /** @private */
2846a4455
> 
2882c4491
<                 console.log("error=", oops);
---
>                 webrtcUtils.log("snedDataP2P error: ", oops);
2886a4496
> 
2919a4530
> 
2937d4547
< 
2947a4558
> 
2967a4579
> 
2987c4599
<             console.error("Developer error, destination was null in sendPeerMessage");
---
>             self.showError(self.errCodes.DEVELOPER_ERR, "destination was null in sendPeerMessage");
3008a4621
> 
3043a4657
> 
3075a4690
> 
3077a4693
> 
3079a4696
> 
3081a4699
> 
3108a4727
> 
3117a4737,4749
>     /** @private */
>     function sendQueuedCandidates(peer, onSignalSuccess, onSignalFailure) {
>         var i;
>         for (i = 0; i < peerConns[peer].candidatesToSend.length; i++) {
>             sendSignalling(
>                     peer,
>                     "candidate",
>                     peerConns[peer].candidatesToSend[i],
>                     onSignalSuccess,
>                     onSignalFailure
>                     );
>         }
>     }
3119,3143c4751,4775
<     /**
<      *  Initiates a call to another user. If it succeeds, the streamAcceptor callback will be called.
<      * @param {String} otherUser - the easyrtcid of the peer being called.
<      * @param {Function} callSuccessCB (otherCaller, mediaType) - is called when the datachannel is established or the MediaStream is established. mediaType will have a value of "audiovideo" or "datachannel"
<      * @param {Function} callFailureCB (errorCode, errMessage) - is called if there was a system error interfering with the call.
<      * @param {Function} wasAcceptedCB (wasAccepted:boolean,otherUser:string) - is called when a call is accepted or rejected by another party. It can be left null.
<      * @param {Array} streamNames - optional array of streamNames.
<      * @example
<      *    easyrtc.call( otherEasyrtcid,
<      *        function(easyrtcid, mediaType){
<      *           console.log("Got mediaType " + mediaType + " from " + easyrtc.idToName(easyrtcid));
<      *        },
<      *        function(errorCode, errMessage){
<      *           console.log("call to  " + easyrtc.idToName(otherEasyrtcid) + " failed:" + errMessage);
<      *        },
<      *        function(wasAccepted, easyrtcid){
<      *            if( wasAccepted ){
<      *               console.log("call accepted by " + easyrtc.idToName(easyrtcid));
<      *            }
<      *            else{
<      *                console.log("call rejected" + easyrtc.idToName(easyrtcid));
<      *            }
<      *        });
<      */
<     this.call = function(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames) {
---
>     /** @private */
>     //
>     // This function calls the users onStreamClosed handler, passing it the easyrtcid of the peer, the stream itself,
>     // and the name of the stream.
>     //
>     function emitOnStreamClosed(easyrtcid, stream) {
>         if (!peerConns[easyrtcid]) {
>             return;
>         }
>         var streamName;
>         var id;
>         if (stream.id) {
>             id = stream.id;
>         }
>         else {
>             id = "default";
>         }
>         streamName = peerConns[easyrtcid].remoteStreamIdToName[id] || "default";
>         if (peerConns[easyrtcid].liveRemoteStreams[streamName] &&
>             self.onStreamClosed) {
>             delete peerConns[easyrtcid].liveRemoteStreams[streamName];
>             self.onStreamClosed(easyrtcid, stream, streamName);
>         }
>         delete peerConns[easyrtcid].remoteStreamIdToName[id];
>     }
3145,3151c4777,4785
<         if (streamNames) {
<             if (typeof streamNames === "string") { // accept a string argument if passed.
<                 streamNames = [streamNames];
<             }
<             else if (typeof streamNames.length === "undefined") {
<                 easyrtc.showError(self.errCodes.DEVELOPER_ERR, "easyrtc.call passed bad streamNames");
<                 return;
---
>     /** @private */
>     function onRemoveStreamHelper(easyrtcid, stream) {
>         if (peerConns[easyrtcid]) {
>             emitOnStreamClosed(easyrtcid, stream);
>             updateConfigurationInfo();
>             if( peerConns[easyrtcid].pc ) {
>                  try {
>                     peerConns[easyrtcid].pc.removeStream(stream);
>                  } catch( err) {}
3153d4786
<         }
3155,3159d4787
<         if (self.debugPrinter) {
<             self.debugPrinter("initiating peer to peer call to " + otherUser +
<                     " audio=" + self.audioEnabled +
<                     " video=" + self.videoEnabled +
<                     " data=" + dataEnabled);
3160a4789
>     }
3162,3165d4790
<         if (!self.supportsPeerConnections()) {
<             callFailureCB(self.errCodes.CALL_ERR, self.getConstantString("noWebrtcSupport"));
<             return;
<         }
3167,3178c4792,4799
<         var message;
<         //
<         // If we are sharing audio/video and we haven't allocated the local media stream yet,
<         // we'll do so, recalling our self on success.
<         //
<         if (!streamNames && autoInitUserMedia) {
<             var stream = self.getLocalStream();
<             if (!stream && (self.audioEnabled || self.videoEnabled)) {
<                 self.initMediaSource(function() {
<                     self.call(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB);
<                 }, callFailureCB);
<                 return;
---
>     /** @private */
>     function buildDeltaRecord(added, deleted) {
>         function objectNotEmpty(obj) {
>             var i;
>             for (i in obj) {
>                 if (obj.hasOwnProperty(i)) {
>                     return true;
>                 }
3179a4801
>             return false;
3182,3187c4804,4806
<         if (!self.webSocket) {
<             message = "Attempt to make a call prior to connecting to service";
<             if (self.debugPrinter) {
<                 self.debugPrinter(message);
<             }
<             throw message;
---
>         var result = {};
>         if (objectNotEmpty(added)) {
>             result.added = added;
3190,3199c4809,4810
<         //
<         // If B calls A, and then A calls B before accepting, then A should treat the attempt to
<         // call B as a positive offer to B's offer.
<         //
<         if (offersPending[otherUser]) {
<             wasAcceptedCB(true);
<             doAnswer(otherUser, offersPending[otherUser], streamNames);
<             delete offersPending[otherUser];
<             self.callCancelled(otherUser, false);
<             return;
---
>         if (objectNotEmpty(deleted)) {
>             result.deleted = deleted;
3202,3209c4813,4814
<         // do we already have a pending call?
<         if (typeof acceptancePending[otherUser] !== 'undefined') {
<             message = "Call already pending acceptance";
<             if (self.debugPrinter) {
<                 self.debugPrinter(message);
<             }
<             callFailureCB(self.errCodes.ALREADY_CONNECTED, message);
<             return;
---
>         if (objectNotEmpty(result)) {
>             return result;
3210a4816,4819
>         else {
>             return null;
>         }
>     }
3212,3215c4821,4829
<         if (use_fresh_ice_each_peer) {
<             self.getFreshIceConfig(function(succeeded) {
<                 if (succeeded) {
<                     callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames);
---
>     /** @private */
>     function findDeltas(oldVersion, newVersion) {
>         var i;
>         var added = {}, deleted = {};
>         var subPart;
>         for (i in newVersion) {
>             if (newVersion.hasOwnProperty(i)) {
>                 if (oldVersion === null || typeof oldVersion[i] === 'undefined') {
>                     added[i] = newVersion[i];
3217,3218c4831,4835
<                 else {
<                     callFailureCB(self.errCodes.CALL_ERR, "Attempt to get fresh ice configuration failed");
---
>                 else if (typeof newVersion[i] === 'object') {
>                     subPart = findDeltas(oldVersion[i], newVersion[i]);
>                     if (subPart !== null) {
>                         added[i] = newVersion[i];
>                     }
3220,3223c4837,4840
<             });
<         }
<         else {
<             callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames);
---
>                 else if (newVersion[i] !== oldVersion[i]) {
>                     added[i] = newVersion[i];
>                 }
>             }
3225,3233c4842,4846
<     };
<     function callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames) {
<         acceptancePending[otherUser] = true;
<         var pc = buildPeerConnection(otherUser, true, callFailureCB, streamNames);
<         var message;
<         if (!pc) {
<             message = "buildPeerConnection failed, call not completed";
<             if (self.debugPrinter) {
<                 self.debugPrinter(message);
---
>         for (i in oldVersion) {
>             if (newVersion.hasOwnProperty(i)) {
>                 if (typeof newVersion[i] === 'undefined') {
>                     deleted[i] = oldVersion[i];
>                 }
3235d4847
<             throw message;
3238,3246c4850,4851
<         peerConns[otherUser].callSuccessCB = callSuccessCB;
<         peerConns[otherUser].callFailureCB = callFailureCB;
<         peerConns[otherUser].wasAcceptedCB = wasAcceptedCB;
<         var peerConnObj = peerConns[otherUser];
<         var setLocalAndSendMessage0 = function(sessionDescription) {
<             if (peerConnObj.cancelled) {
<                 return;
<             }
<             var sendOffer = function() {
---
>         return buildDeltaRecord(added, deleted);
>     }
3248c4853,4868
<                 sendSignalling(otherUser, "offer", sessionDescription, null, callFailureCB);
---
>     /** @private */
>     //
>     // this function collects configuration info that will be sent to the server.
>     // It returns that information, leaving it the responsibility of the caller to
>     // do the actual sending.
>     //
>     function collectConfigurationInfo(/* forAuthentication */) {
>         var p2pList = {};
>         var i;
>         for (i in peerConns) {
>             if (!peerConns.hasOwnProperty(i)) {
>                 continue;
>             }
>             p2pList[i] = {
>                 connectTime: peerConns[i].connectTime,
>                 isInitiator: !!peerConns[i].isInitiator
3250,3251c4870,4885
<             if (sdpLocalFilter) {
<                 sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
---
>         }
> 
>         var newConfig = {
>             userSettings: {
>                 sharingAudio: !!haveAudioVideo.audio,
>                 sharingVideo: !!haveAudioVideo.video,
>                 sharingData: !!dataEnabled,
>                 nativeVideoWidth: self.nativeVideoWidth,
>                 nativeVideoHeight: self.nativeVideoHeight,
>                 windowWidth: window.innerWidth,
>                 windowHeight: window.innerHeight,
>                 screenWidth: window.screen.width,
>                 screenHeight: window.screen.height,
>                 cookieEnabled: navigator.cookieEnabled,
>                 os: navigator.oscpu,
>                 language: navigator.language
3253,3256d4886
<             pc.setLocalDescription(sessionDescription, sendOffer,
<                     function(errorText) {
<                         callFailureCB(self.errCodes.CALL_ERR, errorText);
<                     });
3258,3425d4887
<         setTimeout(function() {
<             //
<             // if the call was cancelled, we don't want to continue getting the offer.
<             // we can tell the call was cancelled because there won't be a peerConn object
<             // for it.
<             //
<             if( !peerConns[otherUser]) {
<                 return;
<             }
<             pc.createOffer(setLocalAndSendMessage0, function(errorObj) {
<                 callFailureCB(self.errCodes.CALL_ERR, JSON.stringify(errorObj));
<             },
<                     receivedMediaConstraints);
<         }, 100);
<     }
<     function hangupBody(otherUser) {
<         var i;
<         if (self.debugPrinter) {
<             self.debugPrinter("Hanging up on " + otherUser);
<         }
<         clearQueuedMessages(otherUser);
<         if (peerConns[otherUser]) {
<             if (peerConns[otherUser].pc) {
<                 var remoteStreams = peerConns[otherUser].pc.getRemoteStreams();
<                 for (i = 0; i < remoteStreams.length; i++) {
<                     if( remoteStreams[i].active ) {
<                         emitOnStreamClosed(otherUser, remoteStreams[i]);
<                         try {
<                             stopStream(remoteStreams[i]);
<                         } catch (err) {
<                         }
<                     }
<                 }
<                 //
<                 // todo: may need to add a few lines here for closing the data channels
<                 //
<                 try {
<                     peerConns[otherUser].pc.close();
<                 } catch (err) {
<                 }
<             }
< 
<             peerConns[otherUser].cancelled = true;
<             delete peerConns[otherUser];
<             if (self.webSocket) {
<                 sendSignalling(otherUser, "hangup", null, function() {
<                 }, function(errorCode, errorText) {
<                     if (self.debugPrinter) {
<                         self.debugPrinter("hangup failed:" + errorText);
<                     }
<                 });
<             }
<             if (acceptancePending[otherUser]) {
<                 delete acceptancePending[otherUser];
<             }
<         }
<     }
< 
<     /**
<      * Hang up on a particular user or all users.
<      *  @param {String} otherUser - the easyrtcid of the person to hang up on.
<      *  @example
<      *     easyrtc.hangup(someEasyrtcid);
<      */
<     this.hangup = function(otherUser) {
<         hangupBody(otherUser);
<         updateConfigurationInfo();
<     };
<     /**
<      * Hangs up on all current connections.
<      * @example
<      *    easyrtc.hangupAll();
<      */
<     this.hangupAll = function() {
< 
<         var sawAConnection = false;
<         for (var otherUser in peerConns) {
<             if (!peerConns.hasOwnProperty(otherUser)) {
<                 continue;
<             }
<             sawAConnection = true;
<             hangupBody(otherUser);
<         }
< 
<         if (sawAConnection) {
<             updateConfigurationInfo();
<         }
<     };
<     /** Checks to see if data channels work between two peers.
<      * @param {String} otherUser - the other peer.
<      * @returns {Boolean} true if data channels work and are ready to be used
<      *   between the two peers.
<      */
<     this.doesDataChannelWork = function(otherUser) {
<         if (!peerConns[otherUser]) {
<             return false;
<         }
<         return !!peerConns[otherUser].dataChannelReady;
<     };
<     /**
<      * Return the media stream shared by a particular peer. This is needed when you
<      * add a stream in the middle of a call.
<      * @param {String} easyrtcid the peer.
<      * @param {String} remoteStreamName an optional argument supplying the streamName.
<      * @returns {Object} A mediaStream.
<      */
<     this.getRemoteStream = function(easyrtcid, remoteStreamName) {
<         if (!peerConns[easyrtcid]) {
<             self.showError(self.errCodes.DEVELOPER_ERR, "attempt to get stream of uncalled party");
<             throw "Developer err: no such stream";
<         }
<         else {
<             return peerConns[easyrtcid].getRemoteStreamByName(remoteStreamName);
<         }
<     };
<     /**
<      * Assign a local streamName to a remote stream so that it can be forwarded to other callers.
<      * @param {String} easyrtcid the peer supplying the remote stream
<      * @param {String} remoteStreamName the streamName supplied by the peer.
<      * @param {String} localStreamName streamName used when passing the stream to other peers.
<      * @example
<      *    easyrtc.makeLocalStreamFromRemoteStream(sourcePeer, "default", "forwardedStream");
<      *    easyrtc.call(nextPeer, callSuccessCB, callFailureCB, wasAcceptedCB, ["forwardedStream"]);
<      */
<     this.makeLocalStreamFromRemoteStream = function(easyrtcid, remoteStreamName, localStreamName) {
<         var remoteStream;
<         if (peerConns[easyrtcid].pc) {
<             remoteStream = peerConns[easyrtcid].getRemoteStreamByName(remoteStreamName);
<             if (remoteStream) {
<                 registerLocalMediaStreamByName(remoteStream, localStreamName);
<             }
<             else {
<                 throw "Developer err: no such stream";
<             }
<         }
<         else {
<             throw "Developer err: no such peer ";
<         }
<     };
< 
<     /**
<      * Add a named local stream to a call.
<      * @param {String} easyrtcId The id of client receiving the stream.
<      * @param {String} streamName The name of the stream.
<      * @param {Function} receiptHandler is a function that gets called when the other side sends a message
<      *   that the stream has been received. The receiptHandler gets called with an easyrtcid and a stream name. This
<      *   argument is optional.
<      */
<     this.addStreamToCall = function(easyrtcId, streamName, receiptHandler) {
<         if( !streamName) {
<             streamName = "default";
<         }
<         var stream = getLocalMediaStreamByName(streamName);
<         if (!stream) {
<             console.log("attempt to add nonexistent stream " + streamName);
<         }
<         else if (!peerConns[easyrtcId] || !peerConns[easyrtcId].pc) {
<             console.log("Can't add stream before a call has started.");
<         }
<         else {
<             var pc = peerConns[easyrtcId].pc;
<             peerConns[easyrtcId].enableNegotiateListener = true;
<             pc.addStream(stream);
<             if( receiptHandler ) {
<                 peerConns[easyrtcId].streamsAddedAcks[streamName] = receiptHandler;
<             }
<         }
<     };
3427,3433c4889,4890
<     //
<     // these three listeners support the ability to add/remove additional media streams on the fly.
<     //
<     this.setPeerListener(function(easyrtcid, msgType, msgData) {
<         if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
<             easyrtc.showError(self.errCodes.DEVELOPER_ERR,
<                   "Attempt to add additional stream before establishing the base call.");
---
>         if (!isEmptyObj(p2pList)) {
>             newConfig.p2pList = p2pList;
3435,3445d4891
<         else {
<             var sdp = msgData.sdp;
<             var pc = peerConns[easyrtcid].pc;
< 
<             var setLocalAndSendMessage1 = function(sessionDescription) {
<                 var sendAnswer = function() {
<                    if (self.debugPrinter) {
<                        self.debugPrinter("sending answer");
<                    }
<                    function onSignalSuccess() {
<                    }
3447,3473c4893,4894
<                    function onSignalFailure(errorCode, errorText) {
<                        delete peerConns[easyrtcid];
<                        self.showError(errorCode, errorText);
<                    }
< 
<                    sendSignalling(easyrtcid, "answer", sessionDescription,
<                            onSignalSuccess, onSignalFailure);
<                    peerConns[easyrtcid].connectionAccepted = true;
<                    sendQueuedCandidates(easyrtcid, onSignalSuccess, onSignalFailure);
<                };
< 
<                if (sdpLocalFilter) {
<                    sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
<                }
<                pc.setLocalDescription(sessionDescription, sendAnswer, function(message) {
<                    self.showError(self.errCodes.INTERNAL_ERR, "setLocalDescription: " + msgData);
<                });
<             };
< 
<             var invokeCreateAnswer = function() {
<                pc.createAnswer(setLocalAndSendMessage1,
<                     function(message) {
<                         self.showError(self.errCodes.INTERNAL_ERR, "create-answer: " + message);
<                     },
<                     receivedMediaConstraints);
<                self.sendPeerMessage(easyrtcid, "__gotAddedMediaStream", {sdp: sdp});
<             };
---
>         return newConfig;
>     }
3475,3478c4896,4897
<             if (self.debugPrinter) {
<                 self.debugPrinter("about to call setRemoteDescription in doAnswer");
<             }
<             try {
---
>     /** @private */
>     function updateConfiguration() {
3480,3488c4899,4909
<                 if (sdpRemoteFilter) {
<                     sdp.sdp = sdpRemoteFilter(sdp.sdp);
<                 }
<                 pc.setRemoteDescription(new RTCSessionDescription(sdp),
<                    invokeCreateAnswer, function(message) {
<                     self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
<                 });
<             } catch (srdError) {
<                 console.log("set remote description failed");
---
>         var newConfig = collectConfigurationInfo(false);
>         //
>         // we need to give the getStats calls a chance to fish out the data.
>         // The longest I've seen it take is 5 milliseconds so 100 should be overkill.
>         //
>         var sendDeltas = function() {
>             var alteredData = findDeltas(oldConfig, newConfig);
>             //
>             // send all the configuration information that changes during the session
>             //
>             if (alteredData) {
3490c4911,4914
<                     self.debugPrinter("saw exception in setRemoteDescription");
---
>                     self.debugPrinter("cfg=" + JSON.stringify(alteredData.added));
>                 }
>                 if (self.webSocket) {
>                     sendSignalling(null, "setUserCfg", {setUserCfg: alteredData.added}, null, null);
3492,3531d4915
<                 self.showError(self.errCodes.INTERNAL_ERR, "setRemoteDescription failed: " + srdError.message);
<             }
<         }
<     }, "__addedMediaStream");
<     this.setPeerListener(function(easyrtcid, msgType, msgData) {
<         if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
<         }
<         else {
<             var sdp = msgData.sdp;
<             if (sdpRemoteFilter) {
<                 sdp.sdp = sdpRemoteFilter(sdp.sdp);
<             }
<             var pc = peerConns[easyrtcid].pc;
<             pc.setRemoteDescription(new RTCSessionDescription(sdp), function(){},
<                     function(message) {
<                        self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
<                     });
<         }
< 
<     }, "__gotAddedMediaStream");
<     this.setPeerListener(function(easyrtcid, msgType, msgData) {
<         if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
<         }
<         else {
<             var stream = peerConns[easyrtcid].getRemoteStreamByName(msgData.streamName);
<             if (stream) {
<                 onRemoveStreamHelper(easyrtcid, stream, msgData.streamName);
<                 stopStream(stream);
<             }
<         }
< 
<     }, "__closingMediaStream");
<     function onRemoveStreamHelper(easyrtcid, stream) {
<         if (peerConns[easyrtcid]) {
<             emitOnStreamClosed(easyrtcid, stream);
<             updateConfigurationInfo();
<             if( peerConns[easyrtcid].pc ) {
<                  try {
<                     peerConns[easyrtcid].pc.removeStream(stream);
<                  } catch( err) {}
3533c4917,4920
< 
---
>             oldConfig = newConfig;
>         };
>         if (oldConfig === {}) {
>             sendDeltas();
3535,3553c4922,4923
<     }
< 
< 
<     this.dumpPeerConnectionInfo = function() {
<         var i;
<         for (var peer in peerConns) {
<             console.log("For peer " + peer);
<             var pc = peerConns[peer].pc;
<             var remotes = pc.getRemoteStreams();
<             var remoteIds = [];
<             for (i = 0; i < remotes.length; i++) {
<                 remoteIds.push(remotes[i].id);
<             }
<             var locals = pc.getLocalStreams();
<             var localIds = [];
<             for (i = 0; i < locals.length; i++) {
<                 localIds.push(locals[i].id);
<             }
<             console.log("    " + JSON.stringify({local: localIds, remote: remoteIds}));
---
>         else {
>             setTimeout(sendDeltas, 100);
3555,3558c4925,4929
<     };
< 
< 
<     var buildPeerConnection = function(otherUser, isInitiator, failureCB, streamNames) {
---
>     }
>     
>     /** @private */
>     // TODO split buildPeerConnection it more thant 500 lines
>     function buildPeerConnection(otherUser, isInitiator, failureCB, streamNames) {
3574c4945
<                         JSON.stringify(ice_config) + ")";
---
>                         JSON.stringify(iceConfig) + ")";
3588c4959
<                 if( peerConns[otherUser].enableNegotiateListener ) {
---
>                 if (peerConns[otherUser] && peerConns[otherUser].enableNegotiateListener) {
3598c4969
<                         console.log("unexpected error in creating offer");
---
>                         webrtcUtils.log("unexpected error in creating offer");
3604c4975,4979
<                 var connState = ev.currentTarget.iceConnectionState;
---
>                 if (iceConnectionStateChangeListener) {
>                    iceConnectionStateChangeListener(otherUser, ev.target);
>                 }
> 
>                 var connState = ev.currentTarget ? ev.currentTarget.iceConnectionState : 'unknown';
3606,3613c4981,4987
<                    case "connected":
<                        if (peerConns[otherUser].callSuccessCB) {
<                             peerConns[otherUser].callSuccessCB(otherUser,
<                                "connection");
<                        }
<                        break;
<                    case "failed":
<                        if (failureCB) {
---
>                     case "connected":
>                         if (peerConns[otherUser] && peerConns[otherUser].callSuccessCB) {
>                             peerConns[otherUser].callSuccessCB(otherUser, "connection");
>                         }
>                         break;
>                     case "failed":
>                         if (failureCB) {
3615,3637c4989,5016
<                        }
<                        delete peerConns[otherUser];
<                        break;
<                    case "disconnected":
<                       if( easyrtc.onPeerFailing ) {
<                           easyrtc.onPeerFailing(otherUser);
<                           peerConns[otherUser].failing = Date.now();
<                       }
<                       break;
< 
<                    case "closed":
<                       if( easyrtc.onPeerClosed ) {
<                           easyrtc.onPeerClosed(otherUser);
<                       }
<                       break;
<                 }
< 
<                 if (connState === 'connected' || connState === 'completed') {
<                    if (peerConns[otherUser].failing && easyrtc.onPeerRecovered) {
<                         easyrtc.onPeerRecovered(otherUser, peerConns[otherUser].failing, Date.now());
<                     }
< 
<                     delete peerConns[otherUser].failing;
---
>                         }
>                         delete peerConns[otherUser];
>                         break;
>                     case "disconnected":
>                         if(self.onPeerFailing) {
>                             self.onPeerFailing(otherUser);
>                         }
>                         if (peerConns[otherUser]) {
>                             peerConns[otherUser].failing = Date.now();
>                         }
>                         break;
> 
>                     case "closed":
>                         if( self.onPeerClosed ) {
>                           self.onPeerClosed(otherUser);
>                         }
>                         break;
> 
>                     case "connected":
>                     case "completed":
>                         if (peerConns[otherUser]) {
>                             if (peerConns[otherUser].failing && self.onPeerRecovered) {
>                                 self.onPeerRecovered(otherUser, peerConns[otherUser].failing, Date.now());
>                             }
>                             delete peerConns[otherUser].failing;
>                          }
>                         delete peerConns[otherUser].failing;
>                         break;
3646a5026
> 
3674,3677c5054,5059
<                         var mediaIds = self.getRoomApiField(roomName, otherUser, "mediaIds");
<                         keyToMatch = mediaIds ? mediaIds[streamName] : null;
<                         if (keyToMatch) {
<                             break;
---
>                         if (self.roomData.hasOwnProperty(roomName)) {
>                             var mediaIds = self.getRoomApiField(roomName, otherUser, "mediaIds");
>                             keyToMatch = mediaIds ? mediaIds[streamName] : null;
>                             if (keyToMatch) {
>                                 break;
>                             }
3700c5082,5327
<                 //                var remoteStreams = peerConns[i].pc.getRemoteStreams();
---
>                 //                var remoteStreams = peerConns[i].pc.getRemoteStreams();
>             };
> 
>             pc.onicecandidate = function(event) {
>                 if (peerConns[otherUser] && peerConns[otherUser].cancelled) {
>                     return;
>                 }
>                 var candidateData;
>                 if (event.candidate && peerConns[otherUser]) {
>                     candidateData = {
>                         type: 'candidate',
>                         label: event.candidate.sdpMLineIndex,
>                         id: event.candidate.sdpMid,
>                         candidate: event.candidate.candidate
>                     };
> 
>                     if( iceCandidateFilter ) {
>                        candidateData = iceCandidateFilter(candidateData, false);
>                        if( !candidateData ) {
>                           return;
>                        }
>                     }
>                     //
>                     // some candidates include ip addresses of turn servers. we'll want those
>                     // later so we can see if our actual connection uses a turn server.
>                     // The keyword "relay" in the candidate identifies it as referencing a
>                     // turn server. The \d symbol in the regular expression matches a number.
>                     //
>                     if (event.candidate.candidate.indexOf("typ relay") > 0) {
>                         var ipAddress = event.candidate.candidate.match(/(udp|tcp) \d+ (\d+\.\d+\.\d+\.\d+)/i)[2];
>                         self._turnServers[ipAddress] = true;
>                     }
> 
>                     if (peerConns[otherUser].connectionAccepted) {
>                         sendSignalling(otherUser, "candidate", candidateData, null, function() {
>                             failureCB(self.errCodes.PEER_GONE, "Candidate disappeared");
>                         });
>                     }
>                     else {
>                         peerConns[otherUser].candidatesToSend.push(candidateData);
>                     }
>                 }
>             };
> 
>             pc.onaddstream = function(event) {
> 
>                 if (peerConns[otherUser] && peerConns[otherUser].cancelled) {
>                     return;
>                 }
> 
>                 if (self.debugPrinter) {
>                     self.debugPrinter("saw incoming media stream");
>                 }                
> 
>                 if (!peerConns[otherUser].startedAV) {
>                     peerConns[otherUser].startedAV = true;
>                     peerConns[otherUser].sharingAudio = haveAudioVideo.audio;
>                     peerConns[otherUser].sharingVideo = haveAudioVideo.video;
>                     peerConns[otherUser].connectTime = new Date().getTime();
>                     if (peerConns[otherUser].callSuccessCB) {
>                         if (peerConns[otherUser].sharingAudio || peerConns[otherUser].sharingVideo) {
>                             peerConns[otherUser].callSuccessCB(otherUser, "audiovideo");
>                         }
>                     }
>                     if (self.audioEnabled || self.videoEnabled) {
>                         updateConfiguration();
>                     }
>                 }
>                 var remoteName = getNameOfRemoteStream(otherUser, event.stream.id || "default");
>                 if (!remoteName) {
>                     remoteName = "default";
>                 }
>                 peerConns[otherUser].remoteStreamIdToName[event.stream.id || "default"] = remoteName;
>                 peerConns[otherUser].liveRemoteStreams[remoteName] = true;
>                 event.stream.streamName = remoteName;
>                 if (self.streamAcceptor) {
>                     self.streamAcceptor(otherUser, event.stream, remoteName);
>                     //
>                     // Inform the other user that the stream they provided has been received.
>                     // This should be moved into signalling at some point
>                     //
>                     self.sendDataWS(otherUser, "easyrtc_streamReceived", {streamName:remoteName},function(){});
>                 }
>             };
> 
>             pc.onremovestream = function(event) {
>                 if (self.debugPrinter) {
>                     self.debugPrinter("saw remove on remote media stream");
>                 }
>                 onRemoveStreamHelper(otherUser, event.stream);
>             };
> 
>             peerConns[otherUser] = newPeerConn;
>         } catch (e) {
>             if (self.debugPrinter) {
>                 self.debugPrinter(JSON.stringify(e));
>             }
>             failureCB(self.errCodes.SYSTEM_ERR, e.message);
>             return null;
>         }
> 
>         var i, stream;
>         if (streamNames) {
>             for (i = 0; i < streamNames.length; i++) {
>                 stream = getLocalMediaStreamByName(streamNames[i]);
>                 if (stream) {
>                     pc.addStream(stream);
>                 }
>                 else {
>                     webrtcUtils.log("Developer error, attempt to access unknown local media stream " + streamNames[i]);
>                 }
>             }
>         }
>         else if (autoInitUserMedia && (self.videoEnabled || self.audioEnabled)) {
>             stream = self.getLocalStream();
>             pc.addStream(stream);
>         }
> 
>         //
>         // This function handles data channel message events.
>         //
>         var pendingTransfer = {};
>         function dataChannelMessageHandler(event) {
>             if (self.debugPrinter) {
>                 self.debugPrinter("saw dataChannel.onmessage event: " + JSON.stringify(event.data));
>             }
> 
>             if (event.data === "dataChannelPrimed") {
>                 self.sendDataWS(otherUser, "dataChannelPrimed", "");
>             }
>             else {
>                 //
>                 // Chrome and Firefox Interop is passing a event with a strange data="", perhaps
>                 // as it's own form of priming message. Comparing the data against "" doesn't
>                 // work, so I'm going with parsing and trapping the parse error.
>                 //
>                 try {
>                     var msg = JSON.parse(event.data);
>                     if (msg) {
>                         if (msg.transfer && msg.transferId) {
>                             if (msg.transfer === 'start') {
>                                 if (self.debugPrinter) {
>                                     self.debugPrinter('start transfer #' + msg.transferId);
>                                 }
> 
>                                 var parts = parseInt(msg.parts);
>                                 pendingTransfer = {
>                                     chunks: [],
>                                     parts: parts,
>                                     transferId: msg.transferId
>                                 };
> 
>                             } else if (msg.transfer === 'chunk') {
>                                 if (self.debugPrinter) {
>                                     self.debugPrinter('got chunk for transfer #' + msg.transferId);
>                                 }
> 
>                                 // check data is valid
>                                 if (!(typeof msg.data === 'string' && msg.data.length <= self.maxP2PMessageLength)) {
>                                     webrtcUtils.log('Developer error, invalid data');
> 
>                                     // check there's a pending transfer
>                                 } else if (!pendingTransfer) {
>                                     webrtcUtils.log('Developer error, unexpected chunk');
> 
>                                 // check that transferId is valid
>                                 } else if (msg.transferId !== pendingTransfer.transferId) {
>                                     webrtcUtils.log('Developer error, invalid transfer id');
> 
>                                 // check that the max length of transfer is not reached
>                                 } else if (pendingTransfer.chunks.length + 1 > pendingTransfer.parts) {
>                                     webrtcUtils.log('Developer error, received too many chunks');
> 
>                                 } else {
>                                     pendingTransfer.chunks.push(msg.data);
>                                 }
> 
>                             } else if (msg.transfer === 'end') {
>                                 if (self.debugPrinter) {
>                                     self.debugPrinter('end of transfer #' + msg.transferId);
>                                 }
> 
>                                 // check there's a pending transfer
>                                 if (!pendingTransfer) {
>                                     webrtcUtils.log('Developer error, unexpected end of transfer');
> 
>                                 // check that transferId is valid
>                                 } else if (msg.transferId !== pendingTransfer.transferId) {
>                                     webrtcUtils.log('Developer error, invalid transfer id');
> 
>                                 // check that all the chunks were received
>                                 } else if (pendingTransfer.chunks.length !== pendingTransfer.parts) {
>                                     webrtcUtils.log('Developer error, received wrong number of chunks');
> 
>                                 } else {
>                                     try {
>                                         var chunkedMsg = JSON.parse(pendingTransfer.chunks.join(''));
>                                         self.receivePeerDistribute(otherUser, chunkedMsg, null);
>                                     } catch (err) {
>                                         webrtcUtils.log('Developer error, unable to parse message');
>                                     }
>                                 }
>                                 pendingTransfer = {  };
> 
>                             } else {
>                                 webrtcUtils.log('Developer error, got an unknown transfer message' + msg.transfer);
>                             }
>                         } else {
>                             self.receivePeerDistribute(otherUser, msg, null);
>                         }
>                     }
>                 }
>                 catch (err) {
>                 }
>             }
>         }
> 
>         function initOutGoingChannel(otherUser) {
>             if (self.debugPrinter) {
>                 self.debugPrinter("saw initOutgoingChannel call");
>             }
>             var dataChannel = pc.createDataChannel(dataChannelName, self.getDatachannelConstraints());
>             peerConns[otherUser].dataChannelS = dataChannel;
>             peerConns[otherUser].dataChannelR = dataChannel;
>             dataChannel.onmessage = dataChannelMessageHandler;
>             dataChannel.onopen = function(event) {
>                 if (self.debugPrinter) {
>                     self.debugPrinter("saw dataChannel.onopen event");
>                 }
>                 if (peerConns[otherUser]) {
>                     dataChannel.send("dataChannelPrimed");
>                 }
>             };
>             dataChannel.onclose = function(event) {
>                 if (self.debugPrinter) {
>                     self.debugPrinter("saw dataChannelS.onclose event");
>                 }
>                 if (peerConns[otherUser]) {
>                     peerConns[otherUser].dataChannelReady = false;
>                     delete peerConns[otherUser].dataChannelS;
>                 }
>                 if (onDataChannelClose) {
>                     onDataChannelClose(otherUser);
>                 }
> 
>                 updateConfigurationInfo();
3702,3704c5329,5339
<             pc.onicecandidate = function(event) {
<                 if (newPeerConn.cancelled) {
<                     return;
---
>         }
> 
>         function initIncomingChannel(otherUser) {
>             if (self.debugPrinter) {
>                 self.debugPrinter("initializing incoming channel handler for " + otherUser);
>             }
> 
>             peerConns[otherUser].pc.ondatachannel = function(event) {
> 
>                 if (self.debugPrinter) {
>                     self.debugPrinter("saw incoming data channel");
3706,3713d5340
<                 var candidateData;
<                 if (event.candidate && peerConns[otherUser]) {
<                     candidateData = {
<                         type: 'candidate',
<                         label: event.candidate.sdpMLineIndex,
<                         id: event.candidate.sdpMid,
<                         candidate: event.candidate.candidate
<                     };
3715,3719c5342,5349
<                     if( iceCandidateFilter ) {
<                        candidateData = iceCandidateFilter(candidateData, false);
<                        if( !candidateData ) {
<                           return;
<                        }
---
>                 var dataChannel = event.channel;
>                 peerConns[otherUser].dataChannelR = dataChannel;
>                 peerConns[otherUser].dataChannelS = dataChannel;
>                 peerConns[otherUser].dataChannelReady = true;
>                 dataChannel.onmessage = dataChannelMessageHandler;
>                 dataChannel.onclose = function(event) {
>                     if (self.debugPrinter) {
>                         self.debugPrinter("saw dataChannelR.onclose event");
3721,3729c5351,5356
<                     //
<                     // some candidates include ip addresses of turn servers. we'll want those
<                     // later so we can see if our actual connection uses a turn server.
<                     // The keyword "relay" in the candidate identifies it as referencing a
<                     // turn server. The \d symbol in the regular expression matches a number.
<                     //
<                     if (event.candidate.candidate.indexOf("typ relay") > 0) {
<                         var ipAddress = event.candidate.candidate.match(/(udp|tcp) \d+ (\d+\.\d+\.\d+\.\d+)/i)[2];
<                         self._turnServers[ipAddress] = true;
---
>                     if (peerConns[otherUser]) {
>                         peerConns[otherUser].dataChannelReady = false;
>                         delete peerConns[otherUser].dataChannelR;
>                     }
>                     if (onDataChannelClose) {
>                         onDataChannelClose(otherUser);
3732,3735c5359,5363
<                     if (peerConns[otherUser].connectionAccepted) {
<                         sendSignalling(otherUser, "candidate", candidateData, null, function() {
<                             failureCB(self.errCodes.PEER_GONE, "Candidate disappeared");
<                         });
---
>                     updateConfigurationInfo();
>                 };
>                 dataChannel.onopen = function(event) {
>                     if (self.debugPrinter) {
>                         self.debugPrinter("saw dataChannel.onopen event");
3737,3738c5365,5366
<                     else {
<                         peerConns[otherUser].candidatesToSend.push(candidateData);
---
>                     if (peerConns[otherUser]) {
>                         dataChannel.send("dataChannelPrimed");
3740c5368
<                 }
---
>                 };
3742,3760c5370,5380
<             pc.onaddstream = function(event) {
<                 if (self.debugPrinter) {
<                     self.debugPrinter("saw incoming media stream");
<                 }
<                 if (newPeerConn.cancelled)
<                     return;
<                 if (!peerConns[otherUser].startedAV) {
<                     peerConns[otherUser].startedAV = true;
<                     peerConns[otherUser].sharingAudio = haveAudioVideo.audio;
<                     peerConns[otherUser].sharingVideo = haveAudioVideo.video;
<                     peerConns[otherUser].connectTime = new Date().getTime();
<                     if (peerConns[otherUser].callSuccessCB) {
<                         if (peerConns[otherUser].sharingAudio || peerConns[otherUser].sharingVideo) {
<                             peerConns[otherUser].callSuccessCB(otherUser, "audiovideo");
<                         }
<                     }
<                     if (self.audioEnabled || self.videoEnabled) {
<                         updateConfiguration();
<                     }
---
>         }
> 
>         //
>         //  added for interoperability
>         //
>         // TODO check if both sides have the same browser and versions
>         if (dataEnabled) {
>             self.setPeerListener(function() {
>                 peerConns[otherUser].dataChannelReady = true;
>                 if (peerConns[otherUser].callSuccessCB) {
>                     peerConns[otherUser].callSuccessCB(otherUser, "datachannel");
3762,3764c5382,5383
<                 var remoteName = getNameOfRemoteStream(otherUser, event.stream.id || "default");
<                 if (!remoteName) {
<                     remoteName = "default";
---
>                 if (onDataChannelOpen) {
>                     onDataChannelOpen(otherUser, true);
3766,3775c5385,5394
<                 peerConns[otherUser].remoteStreamIdToName[event.stream.id || "default"] = remoteName;
<                 peerConns[otherUser].liveRemoteStreams[remoteName] = true;
<                 event.stream.streamName = remoteName;
<                 if (self.streamAcceptor) {
<                     self.streamAcceptor(otherUser, event.stream, remoteName);
<                     //
<                     // Inform the other user that the stream they provided has been received.
<                     // This should be moved into signalling at some point
<                     //
<                     self.sendDataWS(otherUser, "easyrtc_streamReceived", {streamName:remoteName},function(){});
---
>                 updateConfigurationInfo();
>             }, "dataChannelPrimed", otherUser);
>             if (isInitiator) {
>                 try {
> 
>                     initOutGoingChannel(otherUser);
>                 } catch (channelErrorEvent) {
>                     webrtcUtils.log("failed to init outgoing channel");
>                     failureCB(self.errCodes.SYSTEM_ERR,
>                             self.formatError(channelErrorEvent));
3777,3778c5396,5438
<             };
<             pc.onremovestream = function(event) {
---
>             }
>             if (!isInitiator) {
>                 initIncomingChannel(otherUser);
>             }
>         }
> 
>         pc.onconnection = function() {
>             if (self.debugPrinter) {
>                 self.debugPrinter("setup pc.onconnection ");
>             }
>         };
> 
>         //
>         // Temporary support for responding to acknowledgements of about streams being added.
>         //
>         self.setPeerListener(function(easyrtcid, msgType, msgData, targeting){
>              if( newPeerConn.streamsAddedAcks[msgData.streamName]) {
>                  (newPeerConn.streamsAddedAcks[msgData.streamName])(easyrtcid, msgData.streamName);
>                  delete newPeerConn.streamsAddedAcks[msgData.streamName];
>              }
>         }, "easyrtc_streamReceived", otherUser);
>         return pc;
>     }
> 
>     /** @private */
>     function doAnswerBody(caller, msgData, streamNames) {
>         var pc = buildPeerConnection(caller, false, function(message) {
>             self.showError(self.errCodes.SYSTEM_ERR, message);
>         }, streamNames);
>         var newPeerConn = peerConns[caller];
>         if (!pc) {
>             if (self.debugPrinter) {
>                 self.debugPrinter("buildPeerConnection failed. Call not answered");
>             }
>             return;
>         }
>         var setLocalAndSendMessage1 = function(sessionDescription) {
>             
>             if (newPeerConn.cancelled) {
>                 return;
>             }
> 
>             var sendAnswer = function() {
3780c5440,5458
<                     self.debugPrinter("saw remove on remote media stream");
---
>                     self.debugPrinter("sending answer");
>                 }
>                 function onSignalSuccess() {
>                 }
> 
>                 function onSignalFailure(errorCode, errorText) {
>                     delete peerConns[caller];
>                     self.showError(errorCode, errorText);
>                 }
> 
>                 sendSignalling(caller, "answer", sessionDescription,
>                         onSignalSuccess, onSignalFailure);
>                 peerConns[caller].connectionAccepted = true;
>                 sendQueuedCandidates(caller, onSignalSuccess, onSignalFailure);
>                 if (pc.connectDataConnection) {
>                     if (self.debugPrinter) {
>                         self.debugPrinter("calling connectDataConnection(5002,5001)");
>                     }
>                     pc.connectDataConnection(5002, 5001);
3782d5459
<                 onRemoveStreamHelper(otherUser, event.stream, event.stream.id || "default");
3784,3787c5461,5462
<             peerConns[otherUser] = newPeerConn;
<         } catch (e) {
<             if (self.debugPrinter) {
<                 self.debugPrinter(JSON.stringify(e));
---
>             if (sdpLocalFilter) {
>                 sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
3789,3790c5464,5470
<             failureCB(self.errCodes.SYSTEM_ERR, e.message);
<             return null;
---
>             pc.setLocalDescription(sessionDescription, sendAnswer, function(message) {
>                 self.showError(self.errCodes.INTERNAL_ERR, "setLocalDescription: " + message);
>             });
>         };
>         var sd = new RTCSessionDescription(msgData);
>         if (!sd) {
>             throw "Could not create the RTCSessionDescription";
3793,3798c5473,5524
<         var i, stream;
<         if (streamNames) {
<             for (i = 0; i < streamNames.length; i++) {
<                 stream = getLocalMediaStreamByName(streamNames[i]);
<                 if (stream) {
<                     pc.addStream(stream);
---
>         if (self.debugPrinter) {
>             self.debugPrinter("sdp ||  " + JSON.stringify(sd));
>         }
>         var invokeCreateAnswer = function() {
>             if (newPeerConn.cancelled) {
>                 return;
>             }
>             pc.createAnswer(setLocalAndSendMessage1,
>                     function(message) {
>                         self.showError(self.errCodes.INTERNAL_ERR, "create-answer: " + message);
>                     },
>                     receivedMediaConstraints);
>         };
>         if (self.debugPrinter) {
>             self.debugPrinter("about to call setRemoteDescription in doAnswer");
>         }
>         try {
> 
>             if (sdpRemoteFilter) {
>                 sd.sdp = sdpRemoteFilter(sd.sdp);
>             }
>             pc.setRemoteDescription(sd, invokeCreateAnswer, function(message) {
>                 self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
>             });
>         } catch (srdError) {
>             webrtcUtils.log("set remote description failed");
>             if (self.debugPrinter) {
>                 self.debugPrinter("saw exception in setRemoteDescription");
>             }
>             self.showError(self.errCodes.INTERNAL_ERR, "setRemoteDescription failed: " + srdError.message);
>         }
>     }
>     
>     /** @private */
>     function doAnswer(caller, msgData, streamNames) {
>         if (!streamNames && autoInitUserMedia) {
>             var localStream = self.getLocalStream();
>             if (!localStream && (self.videoEnabled || self.audioEnabled)) {
>                 self.initMediaSource(
>                         function() {
>                             doAnswer(caller, msgData);
>                         },
>                         function(errorCode, error) {
>                             self.showError(self.errCodes.MEDIA_ERR, self.format(self.getConstantString("localMediaError")));
>                         });
>                 return;
>             }
>         }
>         if (use_fresh_ice_each_peer) {
>             self.getFreshIceConfig(function(succeeded) {
>                 if (succeeded) {
>                     doAnswerBody(caller, msgData, streamNames);
3801c5527
<                     console.log("Developer error, attempt to access unknown local media stream " + streamNames[i]);
---
>                     self.showError(self.errCodes.CALL_ERR, "Failed to get fresh ice config");
3803c5529
<             }
---
>             });
3805,3807c5531,5532
<         else if (autoInitUserMedia && (self.videoEnabled || self.audioEnabled)) {
<             stream = self.getLocalStream();
<             pc.addStream(stream);
---
>         else {
>             doAnswerBody(caller, msgData, streamNames);
3808a5534
>     }
3810,3814c5536,5543
<         //
<         // This function handles data channel message events.
<         //
<         var pendingTransfer = {};
<         function dataChannelMessageHandler(event) {
---
> 
>     /** @private */
>     function callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames) {
>         acceptancePending[otherUser] = true;
>         var pc = buildPeerConnection(otherUser, true, callFailureCB, streamNames);
>         var message;
>         if (!pc) {
>             message = "buildPeerConnection failed, call not completed";
3816c5545
<                 self.debugPrinter("saw dataChannel.onmessage event: " + JSON.stringify(event.data));
---
>                 self.debugPrinter(message);
3817a5547,5548
>             throw message;
>         }
3819,3820c5550,5556
<             if (event.data === "dataChannelPrimed") {
<                 self.sendDataWS(otherUser, "dataChannelPrimed", "");
---
>         peerConns[otherUser].callSuccessCB = callSuccessCB;
>         peerConns[otherUser].callFailureCB = callFailureCB;
>         peerConns[otherUser].wasAcceptedCB = wasAcceptedCB;
>         var peerConnObj = peerConns[otherUser];
>         var setLocalAndSendMessage0 = function(sessionDescription) {
>             if (peerConnObj.cancelled) {
>                 return;
3822,3835c5558
<             else {
<                 //
<                 // Chrome and Firefox Interop is passing a event with a strange data="", perhaps
<                 // as it's own form of priming message. Comparing the data against "" doesn't
<                 // work, so I'm going with parsing and trapping the parse error.
<                 //
<                 try {
<                     var msg = JSON.parse(event.data);
<                     if (msg) {
<                         if (msg.transfer && msg.transferId) {
<                             if (msg.transfer === 'start') {
<                                 if (self.debugPrinter) {
<                                     self.debugPrinter('start transfer #' + msg.transferId);
<                                 }
---
>             var sendOffer = function() {
3837,3842c5560,5584
<                                 var parts = parseInt(msg.parts);
<                                 pendingTransfer = {
<                                     chunks: [],
<                                     parts: parts,
<                                     transferId: msg.transferId
<                                 };
---
>                 sendSignalling(otherUser, "offer", sessionDescription, null, callFailureCB);
>             };
>             if (sdpLocalFilter) {
>                 sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
>             }
>             pc.setLocalDescription(sessionDescription, sendOffer,
>                     function(errorText) {
>                         callFailureCB(self.errCodes.CALL_ERR, errorText);
>                     });
>         };
>         setTimeout(function() {
>             //
>             // if the call was cancelled, we don't want to continue getting the offer.
>             // we can tell the call was cancelled because there won't be a peerConn object
>             // for it.
>             //
>             if( !peerConns[otherUser]) {
>                 return;
>             }
>             pc.createOffer(setLocalAndSendMessage0, function(errorObj) {
>                 callFailureCB(self.errCodes.CALL_ERR, JSON.stringify(errorObj));
>             },
>                     receivedMediaConstraints);
>         }, 100);
>     }
3844,3847c5586,5610
<                             } else if (msg.transfer === 'chunk') {
<                                 if (self.debugPrinter) {
<                                     self.debugPrinter('got chunk for transfer #' + msg.transferId);
<                                 }
---
>     /**
>      * Initiates a call to another user. If it succeeds, the streamAcceptor callback will be called.
>      * @param {String} otherUser - the easyrtcid of the peer being called.
>      * @param {Function} callSuccessCB (otherCaller, mediaType) - is called when the datachannel is established or the MediaStream is established. mediaType will have a value of "audiovideo" or "datachannel"
>      * @param {Function} callFailureCB (errorCode, errMessage) - is called if there was a system error interfering with the call.
>      * @param {Function} wasAcceptedCB (wasAccepted:boolean,otherUser:string) - is called when a call is accepted or rejected by another party. It can be left null.
>      * @param {Array} streamNames - optional array of streamNames.
>      * @example
>      *    easyrtc.call( otherEasyrtcid,
>      *        function(easyrtcid, mediaType){
>      *           console.log("Got mediaType " + mediaType + " from " + easyrtc.idToName(easyrtcid));
>      *        },
>      *        function(errorCode, errMessage){
>      *           console.log("call to  " + easyrtc.idToName(otherEasyrtcid) + " failed:" + errMessage);
>      *        },
>      *        function(wasAccepted, easyrtcid){
>      *            if( wasAccepted ){
>      *               console.log("call accepted by " + easyrtc.idToName(easyrtcid));
>      *            }
>      *            else{
>      *                console.log("call rejected" + easyrtc.idToName(easyrtcid));
>      *            }
>      *        });
>      */
>     this.call = function(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames) {
3849,3851c5612,5620
<                                 // check data is valid
<                                 if (!(typeof msg.data === 'string' && msg.data.length <= self.maxP2PMessageLength)) {
<                                     console.log('Developer error, invalid data');
---
>         if (streamNames) {
>             if (typeof streamNames === "string") { // accept a string argument if passed.
>                 streamNames = [streamNames];
>             }
>             else if (typeof streamNames.length === "undefined") {
>                 self.showError(self.errCodes.DEVELOPER_ERR, "easyrtc.call passed bad streamNames");
>                 return;
>             }
>         }
3853,3855c5622,5627
<                                     // check there's a pending transfer
<                                 } else if (!pendingTransfer) {
<                                     console.log('Developer error, unexpected chunk');
---
>         if (self.debugPrinter) {
>             self.debugPrinter("initiating peer to peer call to " + otherUser +
>                     " audio=" + self.audioEnabled +
>                     " video=" + self.videoEnabled +
>                     " data=" + dataEnabled);
>         }
3857,3859c5629,5632
<                                 // check that transferId is valid
<                                 } else if (msg.transferId !== pendingTransfer.transferId) {
<                                     console.log('Developer error, invalid transfer id');
---
>         if (!self.supportsPeerConnections()) {
>             callFailureCB(self.errCodes.CALL_ERR, self.getConstantString("noWebrtcSupport"));
>             return;
>         }
3861,3863c5634,5647
<                                 // check that the max length of transfer is not reached
<                                 } else if (pendingTransfer.chunks.length + 1 > pendingTransfer.parts) {
<                                     console.log('Developer error, received too many chunks');
---
>         var message;
>         //
>         // If we are sharing audio/video and we haven't allocated the local media stream yet,
>         // we'll do so, recalling our self on success.
>         //
>         if (!streamNames && autoInitUserMedia) {
>             var stream = self.getLocalStream();
>             if (!stream && (self.audioEnabled || self.videoEnabled)) {
>                 self.initMediaSource(function() {
>                     self.call(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB);
>                 }, callFailureCB);
>                 return;
>             }
>         }
3865,3867c5649,5655
<                                 } else {
<                                     pendingTransfer.chunks.push(msg.data);
<                                 }
---
>         if (!self.webSocket) {
>             message = "Attempt to make a call prior to connecting to service";
>             if (self.debugPrinter) {
>                 self.debugPrinter(message);
>             }
>             throw message;
>         }
3869,3872c5657,5667
<                             } else if (msg.transfer === 'end') {
<                                 if (self.debugPrinter) {
<                                     self.debugPrinter('end of transfer #' + msg.transferId);
<                                 }
---
>         //
>         // If B calls A, and then A calls B before accepting, then A should treat the attempt to
>         // call B as a positive offer to B's offer.
>         //
>         if (offersPending[otherUser]) {
>             wasAcceptedCB(true, otherUser);
>             doAnswer(otherUser, offersPending[otherUser], streamNames);
>             delete offersPending[otherUser];
>             self.callCancelled(otherUser, false);
>             return;
>         }
3874,3876c5669,5677
<                                 // check there's a pending transfer
<                                 if (!pendingTransfer) {
<                                     console.log('Developer error, unexpected end of transfer');
---
>         // do we already have a pending call?
>         if (typeof acceptancePending[otherUser] !== 'undefined') {
>             message = "Call already pending acceptance";
>             if (self.debugPrinter) {
>                 self.debugPrinter(message);
>             }
>             callFailureCB(self.errCodes.ALREADY_CONNECTED, message);
>             return;
>         }
3878,3880c5679,5692
<                                 // check that transferId is valid
<                                 } else if (msg.transferId !== pendingTransfer.transferId) {
<                                     console.log('Developer error, invalid transfer id');
---
>         if (use_fresh_ice_each_peer) {
>             self.getFreshIceConfig(function(succeeded) {
>                 if (succeeded) {
>                     callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames);
>                 }
>                 else {
>                     callFailureCB(self.errCodes.CALL_ERR, "Attempt to get fresh ice configuration failed");
>                 }
>             });
>         }
>         else {
>             callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames);
>         }
>     };
3882,3884c5694,5699
<                                 // check that all the chunks were received
<                                 } else if (pendingTransfer.chunks.length !== pendingTransfer.parts) {
<                                     console.log('Developer error, received wrong number of chunks');
---
>     /** @private */
>     //
>     // this function check the deprecated MediaStream.ended attribute 
>     // and new .active. Also fallback .enable on track for Firefox.
>     //
>     function isStreamActive(stream) {
3886,3894c5701
<                                 } else {
<                                     try {
<                                         var chunkedMsg = JSON.parse(pendingTransfer.chunks.join(''));
<                                         self.receivePeerDistribute(otherUser, chunkedMsg, null);
<                                     } catch (err) {
<                                         console.log('Developer error, unable to parse message');
<                                     }
<                                 }
<                                 pendingTransfer = {  };
---
>         var isActive;
3896,3906c5703,5708
<                             } else {
<                                 console.log('Developer error, got an unknown transfer message' + msg.transfer);
<                             }
<                         } else {
<                             self.receivePeerDistribute(otherUser, msg, null);
<                         }
<                     }
<                 }
<                 catch (err) {
<                 }
<             }
---
>         if (stream.active === true || stream.ended === false)  {
>             isActive = true;
>         } else {
>             isActive = stream.getTracks().reduce(function (track) {
>                 return track.enabled;
>             });
3909,3935c5711,5722
<         function initOutGoingChannel(otherUser) {
<             if (self.debugPrinter) {
<                 self.debugPrinter("saw initOutgoingChannel call");
<             }
<             var dataChannel = pc.createDataChannel(dataChannelName, self.getDatachannelConstraints());
<             peerConns[otherUser].dataChannelS = dataChannel;
<             peerConns[otherUser].dataChannelR = dataChannel;
<             dataChannel.onmessage = dataChannelMessageHandler;
<             dataChannel.onopen = function(event) {
<                 if (self.debugPrinter) {
<                     self.debugPrinter("saw dataChannel.onopen event");
<                 }
<                 if (peerConns[otherUser]) {
<                     dataChannel.send("dataChannelPrimed");
<                 }
<             };
<             dataChannel.onclose = function(event) {
<                 if (self.debugPrinter) {
<                     self.debugPrinter("saw dataChannelS.onclose event");
<                 }
<                 if (peerConns[otherUser]) {
<                     peerConns[otherUser].dataChannelReady = false;
<                     delete peerConns[otherUser].dataChannelS;
<                 }
<                 if (onDataChannelClose) {
<                     onDataChannelClose(otherUser);
<                 }
---
>         return isActive;
>     }
> 
>     /** @private */
>     var queuedMessages = {};
>     
>     /** @private */
>     function clearQueuedMessages(caller) {
>         queuedMessages[caller] = {
>             candidates: []
>         };
>     }
3937,3938c5724,5728
<                 updateConfigurationInfo();
<             };
---
>     /** @private */
>     function hangupBody(otherUser) {
>         var i;
>         if (self.debugPrinter) {
>             self.debugPrinter("Hanging up on " + otherUser);
3939a5730,5731
>         clearQueuedMessages(otherUser);
>         if (peerConns[otherUser]) {
3941,3943c5733,5751
<         function initIncomingChannel(otherUser) {
<             if (self.debugPrinter) {
<                 self.debugPrinter("initializing incoming channel handler for " + otherUser);
---
>             if (peerConns[otherUser].pc) {
>                 
>                 var remoteStreams = peerConns[otherUser].pc.getRemoteStreams();
>                 for (i = 0; i < remoteStreams.length; i++) {
>                     if( isStreamActive(remoteStreams[i])) {
>                         emitOnStreamClosed(otherUser, remoteStreams[i]);
>                         stopStream(remoteStreams[i]);
>                     }
>                 }
>                 //
>                 // todo: may need to add a few lines here for closing the data channels
>                 //
>                 try {
>                     peerConns[otherUser].pc.close();
>                 } catch (err) {
>                     if (self.debugPrinter) {
>                         self.debugPrinter("peer close failed:" + err);
>                     }
>                 }
3946c5754,5755
<             peerConns[otherUser].pc.ondatachannel = function(event) {
---
>             peerConns[otherUser].cancelled = true;
>             delete peerConns[otherUser];
3948,3950c5757,5758
<                 if (self.debugPrinter) {
<                     self.debugPrinter("saw incoming data channel");
<                 }
---
>             if (self.webSocket) {
>                 sendSignalling(otherUser, "hangup", null, function() {
3952,3957c5760
<                 var dataChannel = event.channel;
<                 peerConns[otherUser].dataChannelR = dataChannel;
<                 peerConns[otherUser].dataChannelS = dataChannel;
<                 peerConns[otherUser].dataChannelReady = true;
<                 dataChannel.onmessage = dataChannelMessageHandler;
<                 dataChannel.onclose = function(event) {
---
>                 }, function(errorCode, errorText) {
3959,3966c5762
<                         self.debugPrinter("saw dataChannelR.onclose event");
<                     }
<                     if (peerConns[otherUser]) {
<                         peerConns[otherUser].dataChannelReady = false;
<                         delete peerConns[otherUser].dataChannelR;
<                     }
<                     if (onDataChannelClose) {
<                         onDataChannelClose(otherUser);
---
>                         self.debugPrinter("hangup failed:" + errorText);
3967a5764,5770
>                 });
>             }
>             if (acceptancePending[otherUser]) {
>                 delete acceptancePending[otherUser];
>             }
>         }
>     }
3969,3979c5772,5796
<                     updateConfigurationInfo();
<                 };
<                 dataChannel.onopen = function(event) {
<                     if (self.debugPrinter) {
<                         self.debugPrinter("saw dataChannel.onopen event");
<                     }
<                     if (peerConns[otherUser]) {
<                         dataChannel.send("dataChannelPrimed");
<                     }
<                 };
<             };
---
>     /**
>      * Hang up on a particular user or all users.
>      *  @param {String} otherUser - the easyrtcid of the person to hang up on.
>      *  @example
>      *     easyrtc.hangup(someEasyrtcid);
>      */
>     this.hangup = function(otherUser) {
>         hangupBody(otherUser);
>         updateConfigurationInfo();
>     };
> 
>     /**
>      * Hangs up on all current connections.
>      * @example
>      *    easyrtc.hangupAll();
>      */
>     this.hangupAll = function() {
> 
>         var sawAConnection = false;
>         for (var otherUser in peerConns) {
>             if (!peerConns.hasOwnProperty(otherUser)) {
>                 continue;
>             }
>             sawAConnection = true;
>             hangupBody(otherUser);
3982,3986c5799,5802
<         //
<         //  added for interoperability
<         //
<         var doDataChannels = dataEnabled;
<         if (doDataChannels) {
---
>         if (sawAConnection) {
>             updateConfigurationInfo();
>         }
>     };
3988c5804,5812
<             // check if both sides have the same browser and versions
---
>     /** 
>      * Checks to see if data channels work between two peers.
>      * @param {String} otherUser - the other peer.
>      * @returns {Boolean} true if data channels work and are ready to be used
>      *   between the two peers.
>      */
>     this.doesDataChannelWork = function(otherUser) {
>         if (!peerConns[otherUser]) {
>             return false;
3989a5814,5815
>         return !!peerConns[otherUser].dataChannelReady;
>     };
3991,4003c5817,5832
<         if (doDataChannels) {
<             self.setPeerListener(function() {
<                 peerConns[otherUser].dataChannelReady = true;
<                 if (peerConns[otherUser].callSuccessCB) {
<                     peerConns[otherUser].callSuccessCB(otherUser, "datachannel");
<                 }
<                 if (onDataChannelOpen) {
<                     onDataChannelOpen(otherUser, true);
<                 }
<                 updateConfigurationInfo();
<             }, "dataChannelPrimed", otherUser);
<             if (isInitiator) {
<                 try {
---
>     /**
>      * Return the media stream shared by a particular peer. This is needed when you
>      * add a stream in the middle of a call.
>      * @param {String} easyrtcid the peer.
>      * @param {String} remoteStreamName an optional argument supplying the streamName.
>      * @returns {Object} A mediaStream.
>      */
>     this.getRemoteStream = function(easyrtcid, remoteStreamName) {
>         if (!peerConns[easyrtcid]) {
>             self.showError(self.errCodes.DEVELOPER_ERR, "attempt to get stream of uncalled party");
>             throw "Developer err: no such stream";
>         }
>         else {
>             return peerConns[easyrtcid].getRemoteStreamByName(remoteStreamName);
>         }
>     };
4005,4010c5834,5848
<                     initOutGoingChannel(otherUser);
<                 } catch (channelErrorEvent) {
<                     console.log("failed to init outgoing channel");
<                     failureCB(self.errCodes.SYSTEM_ERR,
<                             self.formatError(channelErrorEvent));
<                 }
---
>     /**
>      * Assign a local streamName to a remote stream so that it can be forwarded to other callers.
>      * @param {String} easyrtcid the peer supplying the remote stream
>      * @param {String} remoteStreamName the streamName supplied by the peer.
>      * @param {String} localStreamName streamName used when passing the stream to other peers.
>      * @example
>      *    easyrtc.makeLocalStreamFromRemoteStream(sourcePeer, "default", "forwardedStream");
>      *    easyrtc.call(nextPeer, callSuccessCB, callFailureCB, wasAcceptedCB, ["forwardedStream"]);
>      */
>     this.makeLocalStreamFromRemoteStream = function(easyrtcid, remoteStreamName, localStreamName) {
>         var remoteStream;
>         if (peerConns[easyrtcid].pc) {
>             remoteStream = peerConns[easyrtcid].getRemoteStreamByName(remoteStreamName);
>             if (remoteStream) {
>                 registerLocalMediaStreamByName(remoteStream, localStreamName);
4012,4013c5850,5851
<             if (!isInitiator) {
<                 initIncomingChannel(otherUser);
---
>             else {
>                 throw "Developer err: no such stream";
4016,4032c5854,5856
< 
<         pc.onconnection = function() {
<             if (self.debugPrinter) {
<                 self.debugPrinter("setup pc.onconnection ");
<             }
<         };
< 
<         //
<         // Temporary support for responding to acknowledgements of about streams being added.
<         //
<         self.setPeerListener(function(easyrtcid, msgType, msgData, targeting){
<              if( newPeerConn.streamsAddedAcks[msgData.streamName]) {
<                  (newPeerConn.streamsAddedAcks[msgData.streamName])(easyrtcid, msgData.streamName);
<                  delete newPeerConn.streamsAddedAcks[msgData.streamName];
<              }
<         }, "easyrtc_streamReceived", otherUser);
<         return pc;
---
>         else {
>             throw "Developer err: no such peer ";
>         }
4034,4046c5858,5869
<     var doAnswer = function(caller, msgData, streamNames) {
<         if (!streamNames && autoInitUserMedia) {
<             var localStream = self.getLocalStream();
<             if (!localStream && (self.videoEnabled || self.audioEnabled)) {
<                 self.initMediaSource(
<                         function() {
<                             doAnswer(caller, msgData);
<                         },
<                         function(errorCode, error) {
<                             self.showError(self.errCodes.MEDIA_ERR, self.format(self.getConstantString("localMediaError")));
<                         });
<                 return;
<             }
---
> 
>     /**
>      * Add a named local stream to a call.
>      * @param {String} easyrtcId The id of client receiving the stream.
>      * @param {String} streamName The name of the stream.
>      * @param {Function} receiptHandler is a function that gets called when the other side sends a message
>      *   that the stream has been received. The receiptHandler gets called with an easyrtcid and a stream name. This
>      *   argument is optional.
>      */
>     this.addStreamToCall = function(easyrtcId, streamName, receiptHandler) {
>         if( !streamName) {
>             streamName = "default";
4048,4056c5871,5876
<         if (use_fresh_ice_each_peer) {
<             self.getFreshIceConfig(function(succeeded) {
<                 if (succeeded) {
<                     doAnswerBody(caller, msgData, streamNames);
<                 }
<                 else {
<                     self.showError(self.errCodes.CALL_ERR, "Failed to get fresh ice config");
<                 }
<             });
---
>         var stream = getLocalMediaStreamByName(streamName);
>         if (!stream) {
>             webrtcUtils.log("attempt to add nonexistent stream " + streamName);
>         }
>         else if (!peerConns[easyrtcId] || !peerConns[easyrtcId].pc) {
>             webrtcUtils.log("Can't add stream before a call has started.");
4059c5879,5884
<             doAnswerBody(caller, msgData, streamNames);
---
>             var pc = peerConns[easyrtcId].pc;
>             peerConns[easyrtcId].enableNegotiateListener = true;
>             pc.addStream(stream);
>             if( receiptHandler ) {
>                 peerConns[easyrtcId].streamsAddedAcks[streamName] = receiptHandler;
>             }
4062a5888,5934
>     //
>     // these three listeners support the ability to add/remove additional media streams on the fly.
>     //
>     this.setPeerListener(function(easyrtcid, msgType, msgData) {
>         if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
>             self.showError(self.errCodes.DEVELOPER_ERR, 
>                   "Attempt to add additional stream before establishing the base call.");
>         }
>         else {
>             var sdp = msgData.sdp;
>             var pc = peerConns[easyrtcid].pc;
> 
>             var setLocalAndSendMessage1 = function(sessionDescription) {
>                 var sendAnswer = function() {
>                    if (self.debugPrinter) {
>                        self.debugPrinter("sending answer");
>                    }
>                    function onSignalSuccess() {
>                    }
> 
>                    function onSignalFailure(errorCode, errorText) {
>                        delete peerConns[easyrtcid];
>                        self.showError(errorCode, errorText);
>                    }
> 
>                    sendSignalling(easyrtcid, "answer", sessionDescription,
>                            onSignalSuccess, onSignalFailure);
>                    peerConns[easyrtcid].connectionAccepted = true;
>                    sendQueuedCandidates(easyrtcid, onSignalSuccess, onSignalFailure);
>                };
> 
>                if (sdpLocalFilter) {
>                    sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
>                }
>                pc.setLocalDescription(sessionDescription, sendAnswer, function(message) {
>                    self.showError(self.errCodes.INTERNAL_ERR, "setLocalDescription: " + msgData);
>                });
>             };
> 
>             var invokeCreateAnswer = function() {
>                pc.createAnswer(setLocalAndSendMessage1,
>                     function(message) {
>                         self.showError(self.errCodes.INTERNAL_ERR, "create-answer: " + message);
>                     },
>                     receivedMediaConstraints);
>                self.sendPeerMessage(easyrtcid, "__gotAddedMediaStream", {sdp: sdp});
>             };
4064,4069d5935
<     var doAnswerBody = function(caller, msgData, streamNames) {
<         var pc = buildPeerConnection(caller, false, function(message) {
<             self.showError(self.errCodes.SYSTEM_ERR, message);
<         }, streamNames);
<         var newPeerConn = peerConns[caller];
<         if (!pc) {
4071c5937
<                 self.debugPrinter("buildPeerConnection failed. Call not answered");
---
>                 self.debugPrinter("about to call setRemoteDescription in doAnswer");
4073,4083c5939
<             return;
<         }
<         var setLocalAndSendMessage1 = function(sessionDescription) {
<             if (newPeerConn.cancelled)
<                 return;
<             var sendAnswer = function() {
<                 if (self.debugPrinter) {
<                     self.debugPrinter("sending answer");
<                 }
<                 function onSignalSuccess() {
<                 }
---
>             try {
4085,4087c5941,5942
<                 function onSignalFailure(errorCode, errorText) {
<                     delete peerConns[caller];
<                     self.showError(errorCode, errorText);
---
>                 if (sdpRemoteFilter) {
>                     sdp.sdp = sdpRemoteFilter(sdp.sdp);
4089,4098c5944,5951
< 
<                 sendSignalling(caller, "answer", sessionDescription,
<                         onSignalSuccess, onSignalFailure);
<                 peerConns[caller].connectionAccepted = true;
<                 sendQueuedCandidates(caller, onSignalSuccess, onSignalFailure);
<                 if (pc.connectDataConnection) {
<                     if (self.debugPrinter) {
<                         self.debugPrinter("calling connectDataConnection(5002,5001)");
<                     }
<                     pc.connectDataConnection(5002, 5001);
---
>                 pc.setRemoteDescription(new RTCSessionDescription(sdp),
>                    invokeCreateAnswer, function(message) {
>                     self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
>                 });
>             } catch (srdError) {
>                 webrtcUtils.log("set remote description failed");
>                 if (self.debugPrinter) {
>                     self.debugPrinter("saw exception in setRemoteDescription");
4100,4102c5953
<             };
<             if (sdpLocalFilter) {
<                 sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
---
>                 self.showError(self.errCodes.INTERNAL_ERR, "setRemoteDescription failed: " + srdError.message);
4104,4113d5954
<             pc.setLocalDescription(sessionDescription, sendAnswer, function(message) {
<                 self.showError(self.errCodes.INTERNAL_ERR, "setLocalDescription: " + message);
<             });
<         };
<         var sd = null;
<         if (window.mozRTCSessionDescription) {
<             sd = new mozRTCSessionDescription(msgData);
<         }
<         else {
<             sd = new RTCSessionDescription(msgData);
4115,4116c5956,5962
<         if (self.debugPrinter) {
<             self.debugPrinter("sdp ||  " + JSON.stringify(sd));
---
>     }, "__addedMediaStream");
> 
>     this.setPeerListener(function(easyrtcid, msgType, msgData) {
>         if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
>             if (self.debugPrinter) {
>                 self.debugPrinter("setPeerListener failed: __gotAddedMediaStream Unknow easyrtcid " + easyrtcid);
>             }
4118,4121c5964,5970
<         var invokeCreateAnswer = function() {
<             if (newPeerConn.cancelled)
<                 return;
<             pc.createAnswer(setLocalAndSendMessage1,
---
>         else {
>             var sdp = msgData.sdp;
>             if (sdpRemoteFilter) {
>                 sdp.sdp = sdpRemoteFilter(sdp.sdp);
>             }
>             var pc = peerConns[easyrtcid].pc;
>             pc.setRemoteDescription(new RTCSessionDescription(sdp), function(){},
4123,4128c5972,5973
<                         self.showError(self.errCodes.INTERNAL_ERR, "create-answer: " + message);
<                     },
<                     receivedMediaConstraints);
<         };
<         if (self.debugPrinter) {
<             self.debugPrinter("about to call setRemoteDescription in doAnswer");
---
>                        self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
>                     });
4130d5974
<         try {
4132,4139c5976,5979
<             if (sdpRemoteFilter) {
<                 sd.sdp = sdpRemoteFilter(sd.sdp);
<             }
<             pc.setRemoteDescription(sd, invokeCreateAnswer, function(message) {
<                 self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
<             });
<         } catch (srdError) {
<             console.log("set remote description failed");
---
>     }, "__gotAddedMediaStream");
> 
>     this.setPeerListener(function(easyrtcid, msgType, msgData) {
>         if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
4141c5981
<                 self.debugPrinter("saw exception in setRemoteDescription");
---
>                 self.debugPrinter("setPeerListener failed: __closingMediaStream Unknow easyrtcid " + easyrtcid);
4143,4157d5982
<             self.showError(self.errCodes.INTERNAL_ERR, "setRemoteDescription failed: " + srdError.message);
<         }
<     };
<     //
<     // This function calls the users onStreamClosed handler, passing it the easyrtcid of the peer, the stream itself,
<     // and the name of the stream.
<     //
<     function emitOnStreamClosed(easyrtcid, stream) {
<         if (!peerConns[easyrtcid]) {
<             return;
<         }
<         var streamName;
<         var id;
<         if (stream.id) {
<             id = stream.id;
4160,4166c5985,5989
<             id = "default";
<         }
<         streamName = peerConns[easyrtcid].remoteStreamIdToName[id] || "default";
<         if (peerConns[easyrtcid].liveRemoteStreams[streamName] &&
<             self.onStreamClosed) {
<             delete peerConns[easyrtcid].liveRemoteStreams[streamName];
<             self.onStreamClosed(easyrtcid, stream, streamName);
---
>             var stream = peerConns[easyrtcid].getRemoteStreamByName(msgData.streamName);
>             if (stream) {
>                 onRemoveStreamHelper(easyrtcid, stream);
>                 stopStream(stream);
>             }
4168,4169d5990
<         delete peerConns[easyrtcid].remoteStreamIdToName[id];
<     }
4171c5992,6017
<     var onRemoteHangup = function(caller) {
---
>     }, "__closingMediaStream");
> 
>     /** @private */
>     this.dumpPeerConnectionInfo = function() {
>         var i;
>         for (var peer in peerConns) {
>             if (peerConns.hasOwnProperty(peer)) {
>                 webrtcUtils.log("For peer " + peer);
>                 var pc = peerConns[peer].pc;
>                 var remotes = pc.getRemoteStreams();
>                 var remoteIds = [];
>                 for (i = 0; i < remotes.length; i++) {
>                     remoteIds.push(remotes[i].id);
>                 }
>                 var locals = pc.getLocalStreams();
>                 var localIds = [];
>                 for (i = 0; i < locals.length; i++) {
>                     localIds.push(locals[i].id);
>                 }
>                 webrtcUtils.log("    " + JSON.stringify({local: localIds, remote: remoteIds}));
>             }
>         }
>     };
>     
>     /** @private */
>     function onRemoteHangup(caller) {
4212,4218c6058,6060
<     };
<     var queuedMessages = {};
<     var clearQueuedMessages = function(caller) {
<         queuedMessages[caller] = {
<             candidates: []
<         };
<     };
---
>     }
>     
>     /** @private */
4236,4239c6078,6081
<       * Checks to see if a particular peer is present in any room.
<       * If it isn't, we assume it's logged out.
<       * @param easyrtcid the easyrtcId of the peer.
<       */
---
>      * Checks to see if a particular peer is present in any room.
>      * If it isn't, we assume it's logged out.
>      * @param easyrtcid the easyrtcId of the peer.
>      */
4244,4246c6086
<     //
<     //
<     //
---
>     /** @private */
4284d6123
< 
4289,4290c6128,6129
<     * than desired. Aggregating timers allow a bunch of events to be collapsed into one by only firing the last
<     * event.
---
>      * than desired. Aggregating timers allow a bunch of events to be collapsed into one by only firing the last
>      * event.
4292c6131
<     */
---
>      */
4326a6166
>     /** @private */
4361,4374c6201,6202
<     function sendQueuedCandidates(peer, onSignalSuccess, onSignalFailure) {
<         var i;
<         for (i = 0; i < peerConns[peer].candidatesToSend.length; i++) {
<             sendSignalling(
<                     peer,
<                     "candidate",
<                     peerConns[peer].candidatesToSend[i],
<                     onSignalSuccess,
<                     onSignalFailure
<                     );
<         }
<     }
< 
<     var onChannelMsg = function(msg, ackAcceptorFunc) {
---
>     /** @private */
>     function onChannelMsg(msg, ackAcceptorFunc) {
4396,4397c6224,6358
<             else {
<                 console.log("Unhandled server message " + JSON.stringify(msg));
---
>             else {
>                 webrtcUtils.log("Unhandled server message " + JSON.stringify(msg));
>             }
>         }
>     }
> 
>     /** @private */
>     function processUrl(url) {
>         var ipAddress;
>         if (url.indexOf('turn:') === 0 || url.indexOf('turns:') === 0) {
>             ipAddress = url.split(/[@:&]/g)[1];
>             self._turnServers[ipAddress] = true;
>         }
>     }
> 
>     /** @private */
>     function processIceConfig(iceConfig) {
> 
>         var i, j, item;
>         
>         pc_config = {
>             iceServers: []
>         };
>         
>         self._turnServers = {};
>         
>         if ( 
>             !iceConfig || 
>                 !iceConfig.iceServers ||
>                     typeof iceConfig.iceServers.length === "undefined"
>         ) {
>             self.showError(
>                 self.errCodes.DEVELOPER_ERR, 
>                 "iceConfig received from server didn't have an array called iceServers, ignoring it"
>             );
>         } else {
>             pc_config = {
>                 iceServers: iceConfig.iceServers
>             };            
>         }
> 
>         for (i = 0; i < iceConfig.iceServers.length; i++) {
>             item = iceConfig.iceServers[i];
>             if( item.urls && item.urls.length ) {
>                for( j = 0; j < item.urls.length; j++ ) {
>                   processUrl(item.urls[j]);
>                } 
>             }
>             else if( item.url ) {
>                processUrl(item.url);
>             }
>          }
>     }
> 
>     /** @private */
>     function processSessionData(sessionData) {
>         if (sessionData) {
>             if (sessionData.easyrtcsid) {
>                 self.easyrtcsid = sessionData.easyrtcsid;
>             }
>             if (sessionData.field) {
>                 sessionFields = sessionData.field;
>             }
>         }
>     }
> 
>     /** @private */
>     function processRoomData(roomData) {
>         self.roomData = roomData;
>         
>         var k, roomName, 
>             stuffToRemove, stuffToAdd, 
>             id, removeId;
> 
>         for (roomName in self.roomData) {
>             if (!self.roomData.hasOwnProperty(roomName)) {
>                 continue;
>             }
>             if (roomData[roomName].roomStatus === "join") {
>                 if (!(self.roomJoin[roomName])) {
>                     self.roomJoin[roomName] = roomData[roomName];
>                 }
>                 var mediaIds = buildMediaIds();
>                 if (mediaIds !== {}) {
>                     self.setRoomApiField(roomName, "mediaIds", mediaIds);
>                 }
>             }
>             else if (roomData[roomName].roomStatus === "leave") {
>                 if (self.roomEntryListener) {
>                     self.roomEntryListener(false, roomName);
>                 }
>                 delete self.roomJoin[roomName];
>                 delete lastLoggedInList[roomName];
>                 continue;
>             }
> 
>             if (roomData[roomName].clientList) {
>                 lastLoggedInList[roomName] = roomData[roomName].clientList;
>             }
>             else if (roomData[roomName].clientListDelta) {
>                 stuffToAdd = roomData[roomName].clientListDelta.updateClient;
>                 if (stuffToAdd) {
>                     for (id in stuffToAdd) {
>                         if (!stuffToAdd.hasOwnProperty(id)) {
>                             continue;
>                         }
>                         if (!lastLoggedInList[roomName]) {
>                             lastLoggedInList[roomName] = [];
>                         }
>                         if( !lastLoggedInList[roomName][id] ) {
>                            lastLoggedInList[roomName][id] = stuffToAdd[id];
>                         }
>                         for( k in stuffToAdd[id] ) {
>                            if( k === "apiField" || k === "presence") {
>                               lastLoggedInList[roomName][id][k] = stuffToAdd[id][k];
>                            }
>                         }
>                     }
>                 }
>                 stuffToRemove = roomData[roomName].clientListDelta.removeClient;
>                 if (stuffToRemove && lastLoggedInList[roomName]) {
>                     for (removeId in stuffToRemove) {
>                         if (stuffToRemove.hasOwnProperty(removeId)) {
>                             delete lastLoggedInList[roomName][removeId];
>                         }
>                     }
>                 }
>             }
>             if (self.roomJoin[roomName] && roomData[roomName].field) {
>                 fields.rooms[roomName] = roomData[roomName].field;
>             }
>             if (roomData[roomName].roomStatus === "join") {
>                 if (self.roomEntryListener) {
>                     self.roomEntryListener(true, roomName);
>                 }
4398a6360
>             processOccupantList(roomName, lastLoggedInList[roomName]);
4400,4401c6362,6366
<     };
<     var onChannelCmd = function(msg, ackAcceptorFn) {
---
>         self.emitEvent("roomOccupant", lastLoggedInList);
>     }
> 
>     /** @private */
>     function onChannelCmd(msg, ackAcceptorFn) {
4425,4436c6390,6393
<             if (window.mozRTCIceCandidate) {
<                 candidate = new mozRTCIceCandidate({
<                     sdpMLineIndex: msgData.label,
<                     candidate: msgData.candidate
<                 });
<             }
<             else {
<                 candidate = new RTCIceCandidate({
<                     sdpMLineIndex: msgData.label,
<                     candidate: msgData.candidate
<                 });
<             }
---
>             candidate = new RTCIceCandidate({
>                 sdpMLineIndex: msgData.label,
>                 candidate: msgData.candidate
>             });
4441c6398
<                 easyrtc.showError(self.errCodes.ICECANDIDATE_ERR, "bad ice candidate (" + domError.name + "): " +
---
>                 self.showError(self.errCodes.ICECANDIDATE_ERR, "bad ice candidate (" + domError.name + "): " + 
4447c6404
<                 var ipAddress = msgData.candidate.match(/(udp|tcp) \d+ (\d+\.\d+\.\d+\.\d+)/i)[1];
---
>                 var ipAddress = msgData.candidate.match(/(udp|tcp) \d+ (\d+\.\d+\.\d+\.\d+)/i)[2];
4469c6426
<                         easyrtc.showError(self.errCodes.DEVELOPER_ERR, "accept callback passed invalid streamNames");
---
>                         self.showError(self.errCodes.DEVELOPER_ERR, "accept callback passed invalid streamNames");
4480c6437
<                         callFailureCB(self.errCodes.CALL_ERR, self.getConstantString("noWebrtcSupport"));
---
>                         self.showError(self.errCodes.CALL_ERR, self.getConstantString("noWebrtcSupport"));
4517a6475
> 
4533,4534d6490
< 
< 
4563,4569c6519
<             var sd = null;
<             if (window.mozRTCSessionDescription) {
<                 sd = new mozRTCSessionDescription(msgData);
<             }
<             else {
<                 sd = new RTCSessionDescription(msgData);
<             }
---
>             var sd = new RTCSessionDescription(msgData);
4589c6539
<                      console.log("setRemoteDescription failed ", message);
---
>                      webrtcUtils.log("setRemoteDescription failed ", message);
4592c6542
<                 console.log("setRemoteDescription failed ", smdException);
---
>                 webrtcUtils.log("setRemoteDescription failed ", smdException);
4608,4842c6558
<                 queuedMessages[caller].candidates.push(msgData);
<             }
<         }
< 
<         switch (msgType) {
<             case "sessionData":
<                 processSessionData(msgData.sessionData);
<                 break;
<             case "roomData":
<                 processRoomData(msgData.roomData);
<                 break;
<             case "iceConfig":
<                 processIceConfig(msgData.iceConfig);
<                 break;
<             case "forwardToUrl":
<                 if (msgData.newWindow) {
<                     window.open(msgData.forwardToUrl.url);
<                 }
<                 else {
<                     window.location.href = msgData.forwardToUrl.url;
<                 }
<                 break;
<             case "offer":
<                 processOffer(caller, msgData);
<                 break;
<             case "reject":
<                 processReject(caller);
<                 break;
<             case "answer":
<                 processAnswer(caller, msgData);
<                 break;
<             case "candidate":
<                 processCandidateQueue(caller, msgData);
<                 break;
<             case "hangup":
<                 onRemoteHangup(caller);
<                 clearQueuedMessages(caller);
<                 break;
<             case "error":
<                 self.showError(msg.errorCode, msg.errorText);
<                 break;
<             default:
<                 console.error("received unknown message type from server, msgType is " + msgType);
<                 return;
<         }
< 
<         if (ackAcceptorFn) {
<             ackAcceptorFn(self.ackMessage);
<         }
<     };
<     function connectToWSServer(successCallback, errorCallback) {
<         var i;
<         if (preallocatedSocketIo) {
<             self.webSocket = preallocatedSocketIo;
<         }
<         else if (!self.webSocket) {
<             try {
<                self.webSocket = io.connect(serverPath, connectionOptions);
<             } catch(socketErr) {
<                errorCallback( self.errCodes.SYSTEM_ERROR,
<                      socketError.toString());
<                return;
<             }
<             if (!self.webSocket) {
<                 throw "io.connect failed";
<             }
<         }
<         else {
<             for (i in self.websocketListeners) {
<                 if (!self.websocketListeners.hasOwnProperty(i)) {
<                     continue;
<                 }
<                 self.webSocket.removeEventListener(self.websocketListeners[i].event,
<                         self.websocketListeners[i].handler);
<             }
<         }
<         self.websocketListeners = [];
<         function addSocketListener(event, handler) {
<             self.webSocket.on(event, handler);
<             self.websocketListeners.push({event: event, handler: handler});
<         }
< 
<         addSocketListener("close", function(event) {
<             console.log("the web socket closed");
<         });
<         addSocketListener('error', function(event) {
<             function handleErrorEvent() {
<                 if (self.myEasyrtcid) {
<                     //
<                     // socket.io version 1 got rid of the socket member, moving everything up one level.
<                     //
<                     if (isSocketConnected(self.webSocket)) {
<                         self.showError(self.errCodes.SIGNAL_ERROR, self.getConstantString("miscSignalError"));
<                     }
<                     else {
<                         /* socket server went down. this will generate a 'disconnect' event as well, so skip this event */
<                         errorCallback(self.errCodes.CONNECT_ERR, self.getConstantString("noServer"));
<                     }
<                 }
<                 else {
<                     errorCallback(self.errCodes.CONNECT_ERR, self.getConstantString("noServer"));
<                 }
<             }
<             handleErrorEvent();
<         });
<         function connectHandler(event) {
<             self.webSocketConnected = true;
<             if (!self.webSocket) {
<                 self.showError(self.errCodes.CONNECT_ERR, self.getConstantString("badsocket"));
<             }
< 
<             if (self.debugPrinter) {
<                 self.debugPrinter("saw socket-server onconnect event");
<             }
<             if (self.webSocketConnected) {
<                 sendAuthenticate(successCallback, errorCallback);
<             }
<             else {
<                 errorCallback(self.errCodes.SIGNAL_ERROR, self.getConstantString("icf"));
<             }
<         }
<         if (isSocketConnected(preallocatedSocketIo)) {
<             connectHandler(null);
<         }
<         else {
<             addSocketListener("connect", connectHandler);
<         }
<         addSocketListener("easyrtcMsg", onChannelMsg);
<         addSocketListener("easyrtcCmd", onChannelCmd);
<         addSocketListener("disconnect", function(/* code, reason, wasClean */) {
<             self.webSocketConnected = false;
<             updateConfigurationInfo = function() {
<             }; // dummy update function
<             oldConfig = {};
<             disconnectBody();
<             if (self.disconnectListener) {
<                 self.disconnectListener();
<             }
<         });
<     }
< 
< 
<     function buildDeltaRecord(added, deleted, modified) {
<         function objectNotEmpty(obj) {
<             var i;
<             for (i in obj) {
<                 if (obj.hasOwnProperty(i)) {
<                     return true;
<                 }
<             }
<             return false;
<         }
< 
<         var result = {};
<         if (objectNotEmpty(added)) {
<             result.added = added;
<         }
< 
<         if (objectNotEmpty(deleted)) {
<             result.deleted = deleted;
<         }
< 
<         if (objectNotEmpty(result)) {
<             return result;
<         }
<         else {
<             return null;
<         }
<     }
< 
<     function findDeltas(oldVersion, newVersion) {
<         var i;
<         var added = {}, deleted = {};
<         var subPart;
<         for (i in newVersion) {
<             if (!newVersion.hasOwnProperty(i)) {
<                 // do nothing
<             }
<             else if (oldVersion === null || typeof oldVersion[i] === 'undefined') {
<                 added[i] = newVersion[i];
<             }
<             else if (typeof newVersion[i] === 'object') {
<                 subPart = findDeltas(oldVersion[i], newVersion[i]);
<                 if (subPart !== null) {
<                     added[i] = newVersion[i];
<                 }
<             }
<             else if (newVersion[i] !== oldVersion[i]) {
<                 added[i] = newVersion[i];
<             }
<         }
<         for (i in oldVersion) {
<             if (!newVersion.hasOwnProperty(i)) {
<                 // do nothing
<             }
<             else if (typeof newVersion[i] === 'undefined') {
<                 deleted = oldVersion[i];
<             }
<         }
< 
<         return buildDeltaRecord(added, deleted);
<     }
< 
< //
< // this function collects configuration info that will be sent to the server.
< // It returns that information, leaving it the responsibility of the caller to
< // do the actual sending.
< //
<     function collectConfigurationInfo(/* forAuthentication */) {
<         var p2pList = {};
<         var i;
<         for (i in peerConns) {
<             if (!peerConns.hasOwnProperty(i)) {
<                 continue;
<             }
<             p2pList[i] = {
<                 connectTime: peerConns[i].connectTime,
<                 isInitiator: !!peerConns[i].isInitiator
<             };
<         }
< 
<         var newConfig = {
<             userSettings: {
<                 sharingAudio: !!haveAudioVideo.audio,
<                 sharingVideo: !!haveAudioVideo.video,
<                 sharingData: !!dataEnabled,
<                 nativeVideoWidth: self.nativeVideoWidth,
<                 nativeVideoHeight: self.nativeVideoHeight,
<                 windowWidth: window.innerWidth,
<                 windowHeight: window.innerHeight,
<                 screenWidth: window.screen.width,
<                 screenHeight: window.screen.height,
<                 cookieEnabled: navigator.cookieEnabled,
<                 os: navigator.oscpu,
<                 language: navigator.language
---
>                 queuedMessages[caller].candidates.push(msgData);
4844,4846d6559
<         };
<         if (!isEmptyObj(p2pList)) {
<             newConfig.p2pList = p2pList;
4848,4850d6560
<         return newConfig;
<     }
<     function updateConfiguration() {
4852,4864c6562,6574
<         var newConfig = collectConfigurationInfo(false);
<         //
<         // we need to give the getStats calls a chance to fish out the data.
<         // The longest I've seen it take is 5 milliseconds so 100 should be overkill.
<         //
<         var sendDeltas = function() {
<             var alteredData = findDeltas(oldConfig, newConfig);
<             //
<             // send all the configuration information that changes during the session
<             //
<             if (alteredData) {
<                 if (self.debugPrinter) {
<                     self.debugPrinter("cfg=" + JSON.stringify(alteredData.added));
---
>         switch (msgType) {
>             case "sessionData":
>                 processSessionData(msgData.sessionData);
>                 break;
>             case "roomData":
>                 processRoomData(msgData.roomData);
>                 break;
>             case "iceConfig":
>                 processIceConfig(msgData.iceConfig);
>                 break;
>             case "forwardToUrl":
>                 if (msgData.newWindow) {
>                     window.open(msgData.forwardToUrl.url);
4866,4867c6576,6577
<                 if (self.webSocket) {
<                     sendSignalling(null, "setUserCfg", {setUserCfg: alteredData.added}, null, null);
---
>                 else {
>                     window.location.href = msgData.forwardToUrl.url;
4869,4873c6579,6601
<             }
<             oldConfig = newConfig;
<         };
<         if (oldConfig === {}) {
<             sendDeltas();
---
>                 break;
>             case "offer":
>                 processOffer(caller, msgData);
>                 break;
>             case "reject":
>                 processReject(caller);
>                 break;
>             case "answer":
>                 processAnswer(caller, msgData);
>                 break;
>             case "candidate":
>                 processCandidateQueue(caller, msgData);
>                 break;
>             case "hangup":
>                 onRemoteHangup(caller);
>                 clearQueuedMessages(caller);
>                 break;
>             case "error":
>                 self.showError(msgData.errorCode, msgData.errorText);
>                 break;
>             default:
>                 self.showError(self.errCodes.DEVELOPER_ERR, "received unknown message type from server, msgType is " + msgType);
>                 return;
4875,4876c6603,6605
<         else {
<             setTimeout(sendDeltas, 100);
---
> 
>         if (ackAcceptorFn) {
>             ackAcceptorFn(self.ackMessage);
4880,4882d6608
<     updateConfigurationInfo = function() {
<         updateConfiguration();
<     };
4889a6616
>             
4891a6619
> 
4893c6621,6626
<             sendSignalling(null, 'setPresence', {setPresence: {'show': state, 'status': statusText}}, null);
---
>             sendSignalling(null, 'setPresence', {
>                 setPresence: {
>                     'show': self.presenceShow, 
>                     'status': self.presenceStatus
>                 }
>             }, null);
4895a6629
> 
4905a6640
> 
4919,5003d6653
<     function processSessionData(sessionData) {
<         if (sessionData) {
<             if (sessionData.easyrtcsid) {
<                 self.easyrtcsid = sessionData.easyrtcsid;
<             }
<             if (sessionData.field) {
<                 sessionFields = sessionData.field;
<             }
<         }
<     }
< 
< 
<     function processRoomData(roomData) {
<         self.roomData = roomData;
<         var roomName;
<         var k;
<         var stuffToRemove;
<         var stuffToAdd;
<         var id, removeId;
<         for (roomName in self.roomData) {
<             if (!self.roomData.hasOwnProperty(roomName)) {
<                 continue;
<             }
<             if (roomData[roomName].roomStatus === "join") {
<                 if (!(self.roomJoin[roomName])) {
<                     self.roomJoin[roomName] = roomData[roomName];
<                 }
<                 var mediaIds = buildMediaIds();
<                 if (mediaIds !== {}) {
<                     self.setRoomApiField(roomName, "mediaIds", mediaIds);
<                 }
<             }
<             else if (roomData[roomName].roomStatus === "leave") {
<                 if (self.roomEntryListener) {
<                     self.roomEntryListener(false, roomName);
<                 }
<                 delete self.roomJoin[roomName];
<                 delete lastLoggedInList[roomName];
<                 continue;
<             }
< 
<             if (roomData[roomName].clientList) {
<                 lastLoggedInList[roomName] = roomData[roomName].clientList;
<             }
<             else if (roomData[roomName].clientListDelta) {
<                 stuffToAdd = roomData[roomName].clientListDelta.updateClient;
<                 if (stuffToAdd) {
<                     for (id in stuffToAdd) {
<                         if (!stuffToAdd.hasOwnProperty(id)) {
<                             continue;
<                         }
<                         if (!lastLoggedInList[roomName]) {
<                             lastLoggedInList[roomName] = [];
<                         }
<                         if( !lastLoggedInList[roomName][id] ) {
<                            lastLoggedInList[roomName][id] = stuffToAdd[id];
<                         }
<                         for( k in stuffToAdd[id] ) {
<                            if( k == "apiField" || k == "presence") {
<                               lastLoggedInList[roomName][id][k] = stuffToAdd[id][k];
<                            }
<                         }
<                     }
<                 }
<                 stuffToRemove = roomData[roomName].clientListDelta.removeClient;
<                 if (stuffToRemove && lastLoggedInList[roomName]) {
<                     for (removeId in stuffToRemove) {
<                         if (stuffToRemove.hasOwnProperty(removeId)) {
<                             delete lastLoggedInList[roomName][removeId];
<                         }
<                     }
<                 }
<             }
<             if (self.roomJoin[roomName] && roomData[roomName].field) {
<                 fields.rooms[roomName] = roomData[roomName].field;
<             }
<             if (roomData[roomName].roomStatus === "join") {
<                 if (self.roomEntryListener) {
<                     self.roomEntryListener(true, roomName);
<                 }
<             }
<             processOccupantList(roomName, lastLoggedInList[roomName]);
<         }
<         self.emitEvent("roomOccupant", lastLoggedInList);
<     }
5021c6671,6788
<             return Object.keys(lastLoggedInList[roomName]);
---
>             return Object.keys(lastLoggedInList[roomName]);
>         }
>     };
> 
>     /**
>      * Returns a map of easyrtcid's of peers in a particular room. You should only test elements in the map to see if they are
>      * null; their actual values are not guaranteed to be the same in different releases.
>      * @param roomName
>      * @returns {Object} of easyrtcids or null if the client is not in the room.
>      * @example
>      *      if( easyrtc.getRoomOccupantsAsMap("default")[some_easyrtcid]) {
>      *          console.log("yep, " + some_easyrtcid + " is in the room");
>      *      }
>      */
>     this.getRoomOccupantsAsMap = function(roomName) {
>         return lastLoggedInList[roomName];
>     };
> 
>     /**
>      * Returns true if the ipAddress parameter was the address of a turn server. This is done by checking against information
>      * collected during peer to peer calls. Don't expect it to work before the first call, or to identify turn servers that aren't
>      * in the ice config.
>      * @param ipAddress
>      * @returns {boolean} true if ip address is known to be that of a turn server, false otherwise.
>      */
>     this.isTurnServer = function(ipAddress) {
>         return !!self._turnServers[ipAddress];
>     };
> 
>     /**
>      * Request fresh ice config information from the server.
>      * This should be done periodically by long running applications.
>      * @param {Function} callback is called with a value of true on success, false on failure.
>      */
>     this.getFreshIceConfig = function(callback) {
>         var dataToShip = {
>             msgType: "getIceConfig",
>             msgData: {}
>         };
>         if (!callback) {
>             callback = function() {
>             };
>         }
>         self.webSocket.json.emit("easyrtcCmd", dataToShip,
>                 function(ackMsg) {
>                     if (ackMsg.msgType === "iceConfig") {
>                         processIceConfig(ackMsg.msgData.iceConfig);
>                         callback(true);
>                     }
>                     else {
>                         self.showError(ackMsg.msgData.errorCode, ackMsg.msgData.errorText);
>                         callback(false);
>                     }
>                 }
>         );
>     };
> 
>     /**
>      * This method allows you to join a single room. It may be called multiple times to be in
>      * multiple rooms simultaneously. It may be called before or after connecting to the server.
>      * Note: the successCB and failureDB will only be called if you are already connected to the server.
>      * @param {String} roomName the room to be joined.
>      * @param {Object} roomParameters application specific parameters, can be null.
>      * @param {Function} successCB called once, with a roomName as it's argument, once the room is joined.
>      * @param {Function} failureCB called if the room can not be joined. The arguments of failureCB are errorCode, errorText, roomName.
>      */
>     this.joinRoom = function(roomName, roomParameters, successCB, failureCB) {
>         if (self.roomJoin[roomName]) {
>             self.showError(self.errCodes.DEVELOPER_ERR, "Attempt to join room " + roomName + " which you are already in.");
>             return;
>         }
> 
>         var newRoomData = {roomName: roomName};
>         if (roomParameters) {
>             try {
>                 JSON.stringify(roomParameters);
>             } catch (error) {
>                 self.showError(self.errCodes.DEVELOPER_ERR, "non-jsonable parameter to easyrtc.joinRoom");
>                 throw "Developer error, see application error messages";
>             }
>             var parameters = {};
>             for (var key in roomParameters) {
>                 if (roomParameters.hasOwnProperty(key)) {
>                     parameters[key] = roomParameters[key];
>                 }
>             }
>             newRoomData.roomParameter = parameters;
>         }
>         var msgData = {
>             roomJoin: {}
>         };
>         var roomData;
>         var signallingSuccess, signallingFailure;
>         if (self.webSocket) {
> 
>             msgData.roomJoin[roomName] = newRoomData;
>             signallingSuccess = function(msgType, msgData) {
> 
>                 roomData = msgData.roomData;
>                 self.roomJoin[roomName] = newRoomData;
>                 if (successCB) {
>                     successCB(roomName);
>                 }
> 
>                 processRoomData(roomData);
>             };
>             signallingFailure = function(errorCode, errorText) {
>                 if (failureCB) {
>                     failureCB(errorCode, errorText, roomName);
>                 }
>                 else {
>                     self.showError(errorCode, self.format(self.getConstantString("unableToEnterRoom"), roomName, errorText));
>                 }
>             };
>             sendSignalling(null, "roomJoin", msgData, signallingSuccess, signallingFailure);
>         }
>         else {
>             self.roomJoin[roomName] = newRoomData;
5022a6790
> 
5026,5029c6794,6798
<      * Returns a map of easyrtcid's of peers in a particular room. You should only test elements in the map to see if they are
<      * null; their actual values are not guaranteed to be the same in different releases.
<      * @param roomName
<      * @returns {Object} of easyrtcids or null if the client is not in the room.
---
>      * This function allows you to leave a single room. Note: the successCB and failureDB
>      *  arguments are optional and will only be called if you are already connected to the server.
>      * @param {String} roomName
>      * @param {Function} successCallback - A function which expects a roomName.
>      * @param {Function} failureCallback - A function which expects the following arguments: errorCode, errorText, roomName.
5031,5033c6800,6802
<      *      if( easyrtc.getRoomOccupantsAsMap("default")[some_easyrtcid]) {
<      *          console.log("yep, " + some_easyrtcid + " is in the room");
<      *      }
---
>      *    easyrtc.leaveRoom("freds_room");
>      *    easyrtc.leaveRoom("freds_room", function(roomName){ console.log("left the room")},
>      *                       function(errorCode, errorText, roomName){ console.log("left the room")});
5035,5036c6804,6827
<     this.getRoomOccupantsAsMap = function(roomName) {
<         return lastLoggedInList[roomName];
---
>     this.leaveRoom = function(roomName, successCallback, failureCallback) {
>         var roomItem;
>         if (self.roomJoin[roomName]) {
>             if (!self.webSocket) {
>                 delete self.roomJoin[roomName];
>             }
>             else {
>                 roomItem = {};
>                 roomItem[roomName] = {roomName: roomName};
>                 sendSignalling(null, "roomLeave", {roomLeave: roomItem},
>                 function(msgType, msgData) {
>                     var roomData = msgData.roomData;
>                     processRoomData(roomData);
>                     if (successCallback) {
>                         successCallback(roomName);
>                     }
>                 },
>                         function(errorCode, errorText) {
>                             if (failureCallback) {
>                                 failureCallback(errorCode, errorText, roomName);
>                             }
>                         });
>             }
>         }
5039,5044c6830,6831
<     /**
<      * Returns true if the ipAddress parameter was the address of a turn server. This is done by checking against information
<      * collected during peer to peer calls. Don't expect it to work before the first call, or to identify turn servers that aren't
<      * in the ice config.
<      * @param ipAddress
<      * @returns {boolean} true if ip address is known to be that of a turn server, false otherwise.
---
>     /** Get a list of the rooms you are in. You must be connected to call this function.
>      * @returns {Object} A map whose keys are the room names
5046,5079c6833,6838
<     this.isTurnServer = function(ipAddress) {
<         return !!self._turnServers[ipAddress];
<     };
<     function processIceConfig(iceConfig) {
<         pc_config = {iceServers: []};
<         self._turnServers = {};
<         var i;
<         var item, fixedItem, username, ipAddress;
<         if (!window.createIceServer) {
<             return;
<         }
<        if( !iceConfig || !iceConfig.iceServers ||
<               typeof iceConfig.iceServers.length === "undefined" ) {
<             self.showError(self.errCodes.DEVELOPER_ERR, "iceConfig received from server didn't have an array called iceServers, ignoring it");
<               iceConfig = { iceServers:[]};
<          }
< 
<         for (i = 0; i < iceConfig.iceServers.length; i++) {
<             item = iceConfig.iceServers[i];
<             if (item.url.indexOf('turn:') === 0) {
<                 if (item.username) {
<                     fixedItem = createIceServer(item.url, item.username, item.credential);
<                 }
<                 else {
<                     self.showError(self.errCodes.DEVELOPER_ERR, "TURN server entry doesn't have a username: " + JSON.stringify(item));
<                 }
<                 ipAddress = item.url.split(/[@:&]/g)[1];
<                 self._turnServers[ipAddress] = true;
<             }
<             else { // is stun server entry
<                 fixedItem = item;
<             }
<             if (fixedItem) {
<                 pc_config.iceServers.push(fixedItem);
---
>     this.getRoomsJoined = function() {
>         var roomsIn = {};
>         var key;
>         for (key in self.roomJoin) {
>             if (self.roomJoin.hasOwnProperty(key)) {
>                 roomsIn[key] = true;
5082c6841,6869
<     }
---
>         return roomsIn;
>     };
> 
>     /** Get server defined fields associated with a particular room. Only valid
>      * after a connection has been made.
>      * @param {String} roomName - the name of the room you want the fields for.
>      * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}} or undefined
>      * if you are not connected to the room.
>      */
>     this.getRoomFields = function(roomName) {
>         return (!fields || !fields.rooms || !fields.rooms[roomName]) ? 
>                     undefined : fields.rooms[roomName];
>     };
>     
>     /** Get server defined fields associated with the current application. Only valid
>      * after a connection has been made.
>      * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}}
>      */
>     this.getApplicationFields = function() {
>         return fields.application;
>     };
> 
>     /** Get server defined fields associated with the connection. Only valid
>      * after a connection has been made.
>      * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}}
>      */
>     this.getConnectionFields = function() {
>         return fields.connection;
>     };
5085,5087c6872,6876
<      * Request fresh ice config information from the server.
<      * This should be done periodically by long running applications.
<      * @param {Function} callback is called with a value of true on success, false on failure.
---
>      * Supply a socket.io connection that will be used instead of allocating a new socket.
>      * The expected usage is that you allocate a websocket, assign options to it, call
>      * easyrtc.useThisSocketConnection, followed by easyrtc.connect or easyrtc.easyApp. Easyrtc will not attempt to
>      * close sockets that were supplied with easyrtc.useThisSocketConnection.
>      * @param {Object} alreadyAllocatedSocketIo A value allocated with the connect method of socket.io.
5089,5109c6878,6879
<     this.getFreshIceConfig = function(callback) {
<         var dataToShip = {
<             msgType: "getIceConfig",
<             msgData: {}
<         };
<         if (!callback) {
<             callback = function() {
<             };
<         }
<         self.webSocket.json.emit("easyrtcCmd", dataToShip,
<                 function(ackMsg) {
<                     if (ackMsg.msgType === "iceConfig") {
<                         processIceConfig(ackMsg.msgData.iceConfig);
<                         callback(true);
<                     }
<                     else {
<                         self.showError(ackMsg.msgData.errorCode, ackMsg.msgData.errorText);
<                         callback(false);
<                     }
<                 }
<         );
---
>     this.useThisSocketConnection = function(alreadyAllocatedSocketIo) {
>         preallocatedSocketIo = alreadyAllocatedSocketIo;
5110a6881,6882
> 
>     /** @private */
5111a6884
>         var msgData = msg.msgData;
5115d6887
<         var msgData = msg.msgData;
5129d6900
< 
5133d6903
< 
5137d6906
< 
5139a6909
>     /** @private */
5145a6916
> 
5154c6925,7052
<         }
---
>         }
> 
>         var msgData = {
>             apiVersion: self.apiVersion,
>             applicationName: self.applicationName,
>             setUserCfg: collectConfigurationInfo(true)
>         };
> 
>         if (!self.roomJoin) {
>             self.roomJoin = {};
>         }
>         if (self.presenceShow) {
>             msgData.setPresence = {
>                 show: self.presenceShow, 
>                 status: self.presenceStatus
>             };
>         }
>         if (self.username) {
>             msgData.username = self.username;
>         }
>         if (self.roomJoin && !isEmptyObj(self.roomJoin)) {
>             msgData.roomJoin = self.roomJoin;
>         }
>         if (easyrtcsid) {
>             msgData.easyrtcsid = easyrtcsid;
>         }
>         if (credential) {
>             msgData.credential = credential;
>         }
> 
>         self.webSocket.json.emit(
>             "easyrtcAuth",
>             {
>                 msgType: "authenticate",
>                 msgData: msgData
>             },
>             function(msg) {
>                 var room;
>                 if (msg.msgType === "error") {
>                     errorCallback(msg.msgData.errorCode, msg.msgData.errorText);
>                     self.roomJoin = {};
>                 }
>                 else {
>                     processToken(msg);
>                     if (self._roomApiFields) {
>                         for (room in self._roomApiFields) {
>                             if (self._roomApiFields.hasOwnProperty(room)) {
>                                 enqueueSendRoomApi(room);
>                             }
>                         }
>                     }
> 
>                     if (successCallback) {
>                         successCallback(self.myEasyrtcid);
>                     }
>                 }
>             }
>         );
>     }
> 
>     /** @private */
>     function connectToWSServer(successCallback, errorCallback) {
>         var i;
>         if (preallocatedSocketIo) {
>             self.webSocket = preallocatedSocketIo;
>         }
>         else if (!self.webSocket) {
>             try {
>                self.webSocket = io.connect(serverPath, connectionOptions);
> 
>                 if (!self.webSocket) {
>                     throw "io.connect failed";
>                 }
> 
>             } catch(socketErr) {
>                 self.webSocket = 0;
>                 errorCallback( self.errCodes.SYSTEM_ERROR, socketErr.toString());
>                
>                return;
>             }
>         }
>         else {
>             for (i in self.websocketListeners) {
>                 if (!self.websocketListeners.hasOwnProperty(i)) {
>                     continue;
>                 }
>                 self.webSocket.removeEventListener(self.websocketListeners[i].event,
>                         self.websocketListeners[i].handler);
>             }
>         }
> 
>         self.websocketListeners = [];
>         
>         function addSocketListener(event, handler) {
>             self.webSocket.on(event, handler);
>             self.websocketListeners.push({event: event, handler: handler});
>         }
> 
>         addSocketListener("close", function(event) {
>             webrtcUtils.log("the web socket closed");
>         });
> 
>         addSocketListener('error', function(event) {
>             function handleErrorEvent() {
>                 if (self.myEasyrtcid) {
>                     //
>                     // socket.io version 1 got rid of the socket member, moving everything up one level.
>                     //
>                     if (isSocketConnected(self.webSocket)) {
>                         self.showError(self.errCodes.SIGNAL_ERR, self.getConstantString("miscSignalError"));
>                     }
>                     else {
>                         /* socket server went down. this will generate a 'disconnect' event as well, so skip this event */
>                         errorCallback(self.errCodes.CONNECT_ERR, self.getConstantString("noServer"));
>                     }
>                 }
>                 else {
>                     errorCallback(self.errCodes.CONNECT_ERR, self.getConstantString("noServer"));
>                 }
>             }
>             handleErrorEvent();
>         });
> 
>         function connectHandler(event) {
>             self.webSocketConnected = true;
>             if (!self.webSocket) {
>                 self.showError(self.errCodes.CONNECT_ERR, self.getConstantString("badsocket"));
>             }
5156,5157c7054,7062
<         if (!self.roomJoin) {
<             self.roomJoin = {};
---
>             if (self.debugPrinter) {
>                 self.debugPrinter("saw socket-server onconnect event");
>             }
>             if (self.webSocketConnected) {
>                 sendAuthenticate(successCallback, errorCallback);
>             }
>             else {
>                 errorCallback(self.errCodes.SIGNAL_ERR, self.getConstantString("icf"));
>             }
5160,5175c7065,7066
<         var msgData = {
<             apiVersion: self.apiVersion,
<             applicationName: self.applicationName,
<             setUserCfg: collectConfigurationInfo(true)
<         };
<         if (self.presenceShow) {
<             msgData.setPresence = {show: self.presenceShow, status: self.presenceStatus};
<         }
<         if (self.username) {
<             msgData.username = self.username;
<         }
<         if (self.roomJoin && !isEmptyObj(self.roomJoin)) {
<             msgData.roomJoin = self.roomJoin;
<         }
<         if (easyrtcsid) {
<             msgData.easyrtcsid = easyrtcsid;
---
>         if (isSocketConnected(preallocatedSocketIo)) {
>             connectHandler(null);
5177,5178c7068,7069
<         if (credential) {
<             msgData.credential = credential;
---
>         else {
>             addSocketListener("connect", connectHandler);
5181,5199c7072,7079
<         self.webSocket.json.emit("easyrtcAuth",
<                 {msgType: "authenticate",
<                     msgData: msgData
<                 },
<         function(msg) {
<             var room;
<             if (msg.msgType === "error") {
<                 errorCallback(msg.msgData.errorCode, msg.msgData.errorText);
<                 self.roomJoin = {};
<             }
<             else {
<                 processToken(msg);
<                 if (self._roomApiFields) {
<                     for (room in self._roomApiFields) {
<                         if (self._roomApiFields.hasOwnProperty(room)) {
<                             _enqueueSendRoomApi(room);
<                         }
<                     }
<                 }
---
>         addSocketListener("easyrtcMsg", onChannelMsg);
>         addSocketListener("easyrtcCmd", onChannelCmd);
>         addSocketListener("disconnect", function(/* code, reason, wasClean */) {
>             
>             self.webSocketConnected = false;
>             updateConfigurationInfo = function() {}; // dummy update function
>             oldConfig = {};
>             disconnectBody();
5201,5203c7081,7082
<                 if (successCallback) {
<                     successCallback(self.myEasyrtcid);
<                 }
---
>             if (self.disconnectListener) {
>                 self.disconnectListener();
5205,5206c7084
<         }
<         );
---
>         });
5209,5258d7086
<     /** Get a list of the rooms you are in. You must be connected to call this function.
<      * @returns {Object} A map whose keys are the room names
<      */
<     this.getRoomsJoined = function() {
<         var roomsIn = {};
<         var key;
<         for (key in self.roomJoin) {
<             if (self.roomJoin.hasOwnProperty(key)) {
<                 roomsIn[key] = true;
<             }
<         }
<         return roomsIn;
<     };
<     /** Get server defined fields associated with a particular room. Only valid
<      * after a connection has been made.
<      * @param {String} roomName - the name of the room you want the fields for.
<      * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}} or undefined
<      * if you are not connected to the room.
<      */
<     this.getRoomFields = function(roomName) {
<         if (!fields || !fields.rooms || !fields.rooms[roomName])
<             return undefined;
<         return fields.rooms[roomName];
<     };
<     /** Get server defined fields associated with the current application. Only valid
<      * after a connection has been made.
<      * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}}
<      */
<     this.getApplicationFields = function() {
<         return fields.application;
<     };
<     /** Get server defined fields associated with the connection. Only valid
<      * after a connection has been made.
<      * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}}
<      */
<     this.getConnectionFields = function() {
<         return fields.connection;
<     };
< 
<     var preallocatedSocketIo = null;
<     /**
<      * Supply a socket.io connection that will be used instead of allocating a new socket.
<      * The expected usage is that you allocate a websocket, assign options to it, call
<      * easyrtc.useThisSocketConnection, followed by easyrtc.connect or easyrtc.easyApp. Easyrtc will not attempt to
<      * close sockets that were supplied with easyrtc.useThisSocketConnection.
<      * @param {Object} alreadyAllocatedSocketIo A value allocated with the connect method of socket.io.
<      */
<     this.useThisSocketConnection = function(alreadyAllocatedSocketIo) {
<         preallocatedSocketIo = alreadyAllocatedSocketIo;
<     };
5260,5263c7088,7106
<      * Connect to the easyrtc signaling server.
<      * @param applicationName
<      * @param successCallback
<      * @param errorCallback
---
>      * Connects to the EasyRTC signaling server. You must connect before trying to
>      * call other users.
>      * @param {String} applicationName is a string that identifies the application so that different applications can have different
>      *        lists of users. Note that the server configuration specifies a regular expression that is used to check application names
>      *        for validity. The default pattern is that of an identifier, spaces are not allowed.
>      * @param {Function} successCallback (easyrtcId, roomOwner) - is called on successful connect. easyrtcId is the
>      *   unique name that the client is known to the server by. A client usually only needs it's own easyrtcId for debugging purposes.
>      *       roomOwner is true if the user is the owner of a room. It's value is random if the user is in multiple rooms.
>      * @param {Function} errorCallback (errorCode, errorText) - is called on unsuccessful connect. if null, an alert is called instead.
>      *  The errorCode takes it's value from easyrtc.errCodes.
>      * @example
>      *   easyrtc.connect("my_chat_app",
>      *                   function(easyrtcid, roomOwner){
>      *                       if( roomOwner){ console.log("I'm the room owner"); }
>      *                       console.log("my id is " + easyrtcid);
>      *                   },
>      *                   function(errorText){
>      *                       console.log("failed to connect ", erFrText);
>      *                   });
5272c7115
<             console.error("Developer error: attempt to connect when already connected to socket server");
---
>             self.showError(self.errCodes.DEVELOPER_ERR, "Attempt to connect when already connected to socket server");
5284a7128
> 
5291c7135
<                 console.error("easyrtc.connect: " + errorText);
---
>                 self.showError(errorCode, errorText);
5297a7142
> 
5298a7144,7174
> /** 
>  *copyright Copyright (c) 2016, Priologic Software Inc.
>  *All rights reserved.</p>
>  *
>  *<p>
>  *Redistribution and use in source and binary forms, with or without
>  *modification, are permitted provided that the following conditions are met:
>  *</p>
>  * <ul>
>  *   <li> Redistributions of source code must retain the above copyright notice,
>  *      this list of conditions and the following disclaimer. </li>
>  *   <li> Redistributions in binary form must reproduce the above copyright
>  *      notice, this list of conditions and the following disclaimer in the
>  *      documentation and/or other materials provided with the distribution. </li>
>  *</ul>
>  *<p>
>  *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
>  *AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
>  *IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
>  *ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
>  *LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
>  *CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
>  *SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
>  *INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
>  *CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
>  *ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
>  *POSSIBILITY OF SUCH DAMAGE.
>  *</p>
>  */
> 
> /* global easyrtc */ // easyrtc.js
5319,5326c7195,7200
<         var numPEOPLE = videoIds.length;
<         var videoIdsP = videoIds;
<         var refreshPane = 0;
<         var onCall = null, onHangup = null;
<         var videoIdToCallerMap = {};
<         if (!videoIdsP) {
<             videoIdsP = [];
<         }
---
> 
>         var videoIdsP = videoIds || [],
>             numPEOPLE = videoIds.length,
>             videoIdToCallerMap = {},
>             onCall = null, 
>             onHangup = null;
5339c7213
<                 self.showError(self.errCodes.DEVELOPER_ERR, "The monitor video id passed to easyApp was bad, saw " + monitorVideoId);
---
>                 easyrtc.showError(easyrtc.errCodes.DEVELOPER_ERR, "The monitor video id passed to easyApp was bad, saw " + monitorVideoId);
5349c7223
<                     self.showError(self.errCodes.DEVELOPER_ERR, "The caller video id '" + name + "' passed to easyApp was bad.");
---
>                     easyrtc.showError(easyrtc.errCodes.DEVELOPER_ERR, "The caller video id '" + name + "' passed to easyApp was bad.");
5364a7239,7272
>         function videoIsFree(obj) {
>             var caller = getCallerOfVideo(obj);
>             return (caller === "" || caller === null || caller === undefined);
>         }
> 
>         function getIthVideo(i) {
>             if (videoIdsP[i]) {
>                 return document.getElementById(videoIdsP[i]);
>             }
>             else {
>                 return null;
>             }
>         }
> 
>         function showVideo(video, stream) {
>             easyrtc.setVideoObjectSrc(video, stream);
>             if (video.style.visibility) {
>                 video.style.visibility = 'visible';
>             }
>         }
> 
>         function hideVideo(video) {
>             easyrtc.setVideoObjectSrc(video, "");
>             video.style.visibility = "hidden";
>         }
> 
>         if (!validateVideoIds(monitorVideoId, videoIdsP)) {
>             throw "bad video element id";
>         }
> 
>         if (monitorVideoId) {
>             document.getElementById(monitorVideoId).muted = "muted";
>         }
> 
5371c7279
< 		        if( !easyrtc.isPeerInAnyRoom(getCallerOfVideo(video))){
---
>                 if( !easyrtc.isPeerInAnyRoom(getCallerOfVideo(video))){
5382,5394d7289
<         function videoIsFree(obj) {
<             var caller = getCallerOfVideo(obj);
<             return (caller === "" || caller === null || caller === undefined);
<         }
< 
<         if (!validateVideoIds(monitorVideoId, videoIdsP)) {
<             throw "bad video element id";
<         }
< 
<         if (monitorVideoId) {
<             document.getElementById(monitorVideoId).muted = "muted";
<         }
< 
5406a7302
> 
5423,5432d7318
<         function getIthVideo(i) {
<             if (videoIdsP[i]) {
<                 return document.getElementById(videoIdsP[i]);
<             }
<             else {
<                 return null;
<             }
<         }
< 
< 
5434c7320
<             if (i < 0 || i > videoIdsP.length) {
---
>             if (i < 0 || i >= videoIdsP.length) {
5450,5453d7335
<         function hideVideo(video) {
<             easyrtc.setVideoObjectSrc(video, "");
<             video.style.visibility = "hidden";
<         }
5467a7350
> 
5482a7366
> 
5488,5493d7371
<             function showVideo(video, stream) {
<                 easyrtc.setVideoObjectSrc(video, stream);
<                 if (video.style.visibility) {
<                     video.style.visibility = 'visible';
<                 }
<             }
5496,5503c7374
<             if (refreshPane && videoIsFree(refreshPane)) {
<                 showVideo(refreshPane, stream);
<                 if (onCall) {
<                     onCall(caller, refreshPane);
<                 }
<                 refreshPane = null;
<                 return;
<             }
---
> 
5526,5528c7397,7399
< //
< // no empty slots, so drop whatever caller we have in the first slot and use that one.
< //
---
>             //
>             // no empty slots, so drop whatever caller we have in the first slot and use that one.
>             //
5536a7408
> 
5539,5541d7410
<         (function() {
<             var addControls, parentDiv, closeButton, i;
<             if (autoAddCloseButtons) {
5543,5555c7412,7425
<                 addControls = function(video) {
<                     parentDiv = video.parentNode;
<                     setCallerOfVideo(video, "");
<                     closeButton = document.createElement("div");
<                     closeButton.className = "easyrtc_closeButton";
<                     closeButton.onclick = function() {
<                         if (getCallerOfVideo(video)) {
<                             easyrtc.hangup(getCallerOfVideo(video));
<                             hideVideo(video);
<                             setCallerOfVideo(video, "");
<                         }
<                     };
<                     parentDiv.appendChild(closeButton);
---
>         var addControls, parentDiv, closeButton, i;
>         if (autoAddCloseButtons) {
> 
>             addControls = function(video) {
>                 parentDiv = video.parentNode;
>                 setCallerOfVideo(video, "");
>                 closeButton = document.createElement("div");
>                 closeButton.className = "easyrtc_closeButton";
>                 closeButton.onclick = function() {
>                     if (getCallerOfVideo(video)) {
>                         easyrtc.hangup(getCallerOfVideo(video));
>                         hideVideo(video);
>                         setCallerOfVideo(video, "");
>                     }
5557,5559c7427,7431
<                 for (i = 0; i < numPEOPLE; i++) {
<                     addControls(getIthVideo(i));
<                 }
---
>                 parentDiv.appendChild(closeButton);
>             };
> 
>             for (i = 0; i < numPEOPLE; i++) {
>                 addControls(getIthVideo(i));
5561c7433,7434
<         })();
---
>         }
> 
5572a7446
> 
5594a7469
>         
5596c7471,7472
<                 gotConnectionCallback = null;
---
>             gotConnectionCallback = null;
> 
5597a7474
> 
5611a7489
> 
5628,5629c7506,7507
<         var nextInitializationStep;
<         nextInitializationStep = function(/* token */) {
---
>         
>         function nextInitializationStep(/* token */) {
5634c7512,7513
<         };
---
>         }
> 
5657,5658d7535
<         
<         
5678c7555
<                     );
---
>                 );
5681,5685d7557
<     /**
<      *
<      * @deprecated now called easyrtc.easyApp.
<      */
<     easyrtc.initManaged = easyrtc.easyApp;
5687,5701c7559,7573
< 
< var easyrtc_constantStrings = {
<   "unableToEnterRoom":"Unable to enter room {0} because {1}" ,
<   "resolutionWarning": "Requested video size of {0}x{1} but got size of {2}x{3}",
<   "badUserName": "Illegal username {0}",
<   "localMediaError": "Error getting local media stream: {0}",
<   "miscSignalError": "Miscellaneous error from signalling server. It may be ignorable.",
<   "noServer": "Unable to reach the EasyRTC signalling server.",
<   "badsocket": "Socket.io connect event fired with bad websocket.",
<   "icf": "Internal communications failure",
<   "statsNotSupported":"call statistics not supported by this browser, try Chrome.",
<    "noWebrtcSupport":"Your browser doesn't appear to support WebRTC.",
<    "gumFailed":"Failed to get access to local media. Error code was {0}.",
<    "requireAudioOrVideo":"At least one of audio and video must be provided"   
< };
\ No newline at end of file
---
> 
> var easyrtc_constantStrings = {
>   "unableToEnterRoom":"Unable to enter room {0} because {1}" ,
>   "resolutionWarning": "Requested video size of {0}x{1} but got size of {2}x{3}",
>   "badUserName": "Illegal username {0}",
>   "localMediaError": "Error getting local media stream: {0}",
>   "miscSignalError": "Miscellaneous error from signalling server. It may be ignorable.",
>   "noServer": "Unable to reach the EasyRTC signalling server.",
>   "badsocket": "Socket.io connect event fired with bad websocket.",
>   "icf": "Internal communications failure",
>   "statsNotSupported":"call statistics not supported by this browser, try Chrome.",
>    "noWebrtcSupport":"Your browser doesn't appear to support WebRTC.",
>    "gumFailed":"Failed to get access to local media. Error code was {0}.",
>    "requireAudioOrVideo":"At least one of audio and video must be provided"   
> };
